(page "index.html"
  (:require [goog.dom :as gdom]
            [goog.string :as gstring]
            [goog.string.format]
            [goog.style :as gstyle]
            [cljs.core.async :as async
             :refer [<! >! timeout]]
            [lsobot.acmi :as acmi]
            [lsobot.grading :as grading]
            [lsobot.units :as units]
            [hoplon.svg :as svg]
            [taoensso.timbre :as log
             :refer-macros (log trace debug info warn error fatal report
                                logf tracef debugf infof warnf errorf fatalf reportf
                                spy get-env log-env)])
  (:require-macros
   [cljs.core.async.macros :refer [go go-loop]]
   [lsobot.macros :refer [formula-of defformula]]))

(defc pass-parameters grading/default-parameters)

(defc acmi nil)

(defc loading? false)

(defc selected-pass-index nil)

(defn get-passes
  [acmi params]
  (->>  (for [[carrier-id pilot-passes] (grading/passes acmi params)
              [pilot-id passes] pilot-passes
              pass-frames passes]
          (do
           (log/debug "get-passes"
                      :carrier-id carrier-id
                      :pilot-id pilot-id
                      :pass-frames (count pass-frames))
           {:frames     pass-frames
            :carrier-id carrier-id
            :start      (-> pass-frames first first)
            :pilot-id   pilot-id}))
        (map-indexed (fn [index m]
                       (assoc m :index index)))))

(defformula passes
  [acmi pass-parameters]
  (get-passes acmi pass-parameters))

(defformula final-entities
  [acmi]
  (-> acmi
      ::acmi/frames
      last
      second
      ::acmi/entities))

(defformula reference-time
  [final-entities]
  (get-in final-entities ["0" "ReferenceTime"]))

(defformula selected-pass
  [selected-pass-index passes acmi]
  (when selected-pass-index
    (nth passes selected-pass-index)))

(defn load-acmi
  [_]
  (let [i (gdom/createElement "input")
        ch (async/chan)]
    (-> i .-type (set! "file"))
    (-> (gdom/getDocument) .-body (gdom/appendChild i))
    (gstyle/showElement i false)
    (-> i .-onchange (set! (fn [e]
                             (async/put! ch e)
                             (async/close! ch))))
    (.click i)
    (go
      (let [e (<! ch)]
        (when-let [file (aget (.. e -target -files) 0)]
          (let [reader (js/FileReader.)]
            (-> reader
                .-onload
                (set! #(do
                         (reset! loading? true)
                         (go
                           (<! (async/timeout 250))
                           (let [contents (-> % .-target .-result)]
                             (reset! acmi (acmi/read-acmi contents))
                             (reset! selected-pass-index
                                     (if (= 1 (log/spy (count @passes)))
                                       0
                                       nil))
                             (reset! loading? false))))))
            (.readAsText reader file)))))))

(defn time-str
  [ref-time t]
  ;; For now we're just going to assume the reference time is midnight
  (let [s (mod t 60)
        t (long (/ t 60))
        m (mod t 60)
        h (long (/ t 60))]
    (gstring/format "%02d:%02d:%02d" h m s)))

(defn property
  [id prop]
  (get-in @final-entities [id prop]))


(def view-bounds
  {:west -1500
   :east (units/nm->ft 2)
   :north (units/nm->ft -0.4)
   :south (units/nm->ft 0.4)
   :high (units/nm->ft 0.6)
   :low -500})

(defn carrier-elevation
  "SVG data for the elevation view of the carrier"
  [deck-height]
  (svg/g
   ;; TODO: Change this so that the zero point matches the location of
   ;; the landing point
   :transform (gstring/format "scale(-1 1) translate(1070 -%f)" (double deck-height))
   (svg/defs
     (svg/path
      :id "carrier-outline-elevation"
      ;; The class attribute doesn't work correctly on SVG
      ;; elements, but we can use :attr to pull it off.
      :attr {:class "carrier-side"}
      :d (gstring/format "M-50 0
L0 %f
L-1100 %f
L-1100 0"
                 (double deck-height)
                 (double deck-height))))
   (svg/use
    :href "#carrier-outline-elevation")
   (svg/rect
    :attr {:class "carrier-side"}
    :x -850
    :y deck-height
    :width 150
    :height 90)
   (svg/rect
    :attr {:class "carrier-side"}
    :x -800
    :y 150
    :width 50
    :height deck-height)
   (svg/rect
    :attr {:class "carrier-side"}
    :x -850
    :y 150
    :width 25
    :height 40)))

(defn carrier-plan
  []
  "SVG data for the plan view of the carrier"
  (svg/g
   (svg/defs
     ;; The carrier outline, relative to an origin at the port aft (is
     ;; this right?) corner, with X increasing to starboard, and Y
     ;; increasing forward
     (svg/path
      :id "carrier-outline"
      ;; The class attribute doesn't work correctly on SVG
      ;; elements, but we can use :attr to pull it off.
      :attr {:class "carrier-top"}
      :d "M80 1100
L250 1100
L280 920
L280 350
L200 200
L180 0
L100 0
L80 200
L0 350
L0 920
L30 1100")
     (svg/clipPath
      :id "carrier-outline-clip"
      (svg/use :href "#carrier-outline")))
   (svg/g
    :transform "rotate(-83) translate(-130 -1050)"
    (svg/use
     :href "#carrier-outline")
    (svg/g
     :clip-path "url(#carrier-outline-clip)"
     (svg/g
      :transform (gstring/format "rotate(-7 180 1100)")
      (svg/line
       :attr {:class "carrier-top-markings end"}
       :x1 "180"
       :y1 "1090"
       :x2 "100"
       :y2 "1090")
      (svg/line
       :attr {:class "carrier-top-markings"}
       :x1 "180"
       :y1 "1100"
       :x2 "180"
       :y2 "0")
      (svg/line
       :attr {:class "carrier-top-markings"}
       :x1 "100"
       :y1 "1100"
       :x2 "100"
       :y2 "0")
      (svg/line
       :attr {:class "carrier-top-markings middle"}
       :x1 "140"
       :y1 "1100"
       :x2 "140"
       :y2 "0"))))))

(def elevation-exaggeration 4)

(defn elevation-path
  [pass]
  (let [{:keys [frames pilot-id]} pass]
    (svg/g
     :attr {:class "approach-path"}
     (for [[t data] frames]
       (let [{:keys [::grading/downrange
                     ::grading/height]} data]
         (svg/circle
          :cx downrange
          :cy (* elevation-exaggeration height)
          :r 25))))))

(def angular-exaggeration 5)

(defn exaggerate-angle
  "Map a cartesian coordinate into polar coordinates, multiplies theta by factor, and translates back into cartian coordinates"
  [[x y] factor]
  (let [r (Math/sqrt (* x x) (* y y))
        ax (Math/abs x)
        ay (Math/abs y)
        theta (Math/atan2 ay ax)
        x' (* r (Math/cos (* theta factor)))
        y' (* r (Math/sin (* theta factor)))]
    ;; Sign of coordinates should match original signs
    [(* x' (/ x ax))
     (* y' (/ y ay))]))

(defn plan-path
  [pass]
  (let [{:keys [frames]} pass]
    (svg/g
     :attr {:class "approach-path"}
     (for [[t data] frames]
       (let [{:keys [::grading/downrange
                     ::grading/crosstrack-error]} data
             [downrange* crosstrack*] (exaggerate-angle [downrange crosstrack-error]
                                                        angular-exaggeration)]
         ;; TODO: Exaggerate the angle to make errors more obvious
         (svg/circle
          :cx (if (pos? downrange) downrange* downrange)
          :cy (if (pos? downrange) crosstrack* crosstrack-error)
          :r 25))))))

(defn elevation
  "Draws the side view of the pass."
  []
  (formula-of
   [pass-parameters selected-pass]
   (let [{:keys [west east high low]} view-bounds
         [x y z] (:landing-point pass-parameters)]
     (svg/svg
      :viewBox (gstring/format "%d %d %d %d"
                               west
                               (- high z)
                               (- east west)
                               (- high low))
      :id "elevation"
      (svg/g
       :transform (gstring/format "scale(1 -1) translate(0 -%f)"
                                  (* 2 high))
       (svg/rect
        :attr {:class "sky"}
        :x west
        :y (- z)
        :width (- east west)
        :height (+ (* 2 z) high))
       (carrier-elevation z)
       (svg/circle
        :attr {:class "landing-point-dot"}
        :cx 0
        :cy 0
        :r 20)
       (when selected-pass
         (elevation-path selected-pass)))))))

(defn plan
  "Draws the top view of the pass."
  []
  (let [{:keys [west east north south]} view-bounds]
    (svg/svg
     :id "plan"
     :viewBox (gstring/format "%d %d %d %d"
                              west
                              north
                              (- east west)
                              (- south north))
     (carrier-plan)
     (svg/line
      :attr {:class "plan angle zero guideline"}
      :x1 west
      :y1 0
      :x2 east
      :y2 0)
     (for [x (range 0 east 1000)]
       [(svg/line
          :attr {:class "plan range guideline"}
          :x1 x
          :y1 north
          :x2 x
          :y2 south)
        (svg/text
         :attr {:class "axis-label plan range"}
         :x x
         :y south
         (str x))])
     (for [x (range -3 4 1)]
       (svg/line
        :transform (gstring/format "rotate(%f)" (* x angular-exaggeration))
        :attr {:class "plan angle guideline"}
        :x1 0
        :y1 0
        :x2 (* east 2)
        :y2 0))
     (svg/g
      ;; We need to invert the y axis because of the way the coordinate
      ;; systems interact: in landing space, crosstrack error increases
      ;; to the right
      :transform "scale(1 -1)"
      (formula-of
       [selected-pass]
       (when selected-pass
         (plan-path selected-pass)))
      (svg/circle
       :attr {:class "landing-point-dot"}
       :cx 0
       :cy 0
       :r 20)))))

(defmethod do! :viewBox
    [elem _ value]
    (if (= false value)
        (.removeAttribute elem "viewBox")
        (.setAttribute elem "viewBox" value)))

(html
 (head
  (title "LSOBot")
  (link :href "style.css" :rel "stylesheet" :title "main" :type "text/css")
  (link :href "https://fonts.googleapis.com/css?family=Open+Sans+Condensed:300"
        :rel "stylesheet"
        :type "text/css"))
 (body
  (div :id "titlebar"
       (div :id "words"
            (span :id "title"
                  "LSOBot")
            (span :id "byline"
                  "by"
                  (a :href "http://firstfighterwing.com/VFW/member.php?893-Tyrant"
                     :target "_blank"
                     "Tyrant"))
            (span :id "helpstring"
                  "Help? Bug? Feature request? Click"
                  (a :href "help.html"
                     :target "_blank"
                     "here")
                  "."))
       (a :href "http://firstfighterwing.com"
          :target "_blank"
          (img :id "winglogo"
               :src "images/1stVFW_Insignia-64.png")))
  (button :click load-acmi "Load ACMI")
  (if-tpl loading?
    (img :id "spinner" :src "images/spinner.gif")
    (let [mt? (cell= (empty? passes))]
      (div
       (if-tpl mt?
         (div "No passes detected")
         [(table
           :id "passes"
           (thead (tr (td) (td "Carrier") (td "Pilot") (td "Pass time")))
           (tbody
            (for-tpl [{:keys [carrier-id pilot-id start index]} passes]
              (do
                (log/debug :index index
                           :carrier-id carrier-id
                           :pilot-id pilot-id)
                (tr
                 (td (input :type "radio"
                            :name "pass"
                            :click #(reset! selected-pass-index @index)
                            :checked (formula-of
                                      [selected-pass-index]
                                      (= selected-pass-index index))))
                 (td (cell= (property carrier-id "Name")))
                 (td (cell= (property pilot-id ::acmi/pilot)))
                 (td (cell= (time-str reference-time start))))))))])
       (elevation)
       (plan))))))
