(page "index.html"
  (:require [goog.dom :as gdom]
            [goog.string :as gstring]
            [goog.string.format]
            [goog.style :as gstyle]
            [cljs.core.async :as async
             :refer [<! >! timeout]]
            [lsobot.acmi :as acmi]
            [lsobot.grading :as grading]
            [lsobot.units :as units]
            [hoplon.svg :as svg]
            [taoensso.timbre :as log
             :refer-macros (log trace debug info warn error fatal report
                                logf tracef debugf infof warnf errorf fatalf reportf
                                spy get-env log-env)])
  (:require-macros
   [cljs.core.async.macros :refer [go go-loop]]
   [lsobot.macros :refer [formula-of defformula]]))

(defc acmi nil)

(defc loading? false)

(defc selected-pass-index nil)

(defn get-passes
  [acmi]
  (->>  (for [[carrier-id pilot-passes] (grading/passes acmi)
              [pilot-id passes] pilot-passes
              pass-frames passes]
          {:frames     pass-frames
           :carrier-id carrier-id
           :pilot-id   pilot-id})
        (map-indexed (fn [index m]
                       (assoc m :index index)))))

(defformula passes
  [acmi]
  (get-passes acmi))

(defformula final-entities
  [acmi]
  (-> acmi
      ::acmi/frames
      last
      second
      ::acmi/entities))

(defformula reference-time
  [final-entities]
  (get-in final-entities ["0" "ReferenceTime"]))

(defformula selected-pass
  [selected-pass-index passes acmi]
  (when selected-pass-index
    (nth passes selected-pass-index)))

(defn load-acmi
  [_]
  (let [i (gdom/createElement "input")
        ch (async/chan)]
    (-> i .-type (set! "file"))
    (-> (gdom/getDocument) .-body (gdom/appendChild i))
    (gstyle/showElement i false)
    (-> i .-onchange (set! (fn [e]
                             (async/put! ch e)
                             (async/close! ch))))
    (.click i)
    (go
      (let [e (<! ch)]
        (when-let [file (aget (.. e -target -files) 0)]
          (let [reader (js/FileReader.)]
            (-> reader
                .-onload
                (set! #(do
                         (reset! loading? true)
                         (go
                           (<! (async/timeout 250))
                           (let [contents (-> % .-target .-result)]
                             (reset! acmi (acmi/read-acmi contents))
                             (reset! selected-pass-index
                                     (if (= 1 (log/spy (count @passes)))
                                       0
                                       nil))
                             (reset! loading? false))))))
            (.readAsText reader file)))))))

(defn time-str
  [ref-time t]
  ;; For now we're just going to assume the reference time is midnight
  (let [s (mod t 60)
        t (long (/ t 60))
        m (mod t 60)
        h (long (/ t 60))]
    (gstring/format "%02d:%02d:%02d" h m s)))

(defn property
  [id prop]
  (get-in @final-entities [id prop]))


(def view-bounds
  {:west -1500
   :east (units/nm->ft 2)
   :north (units/nm->ft -0.5)
   :south (units/nm->ft 0.5)
   :high (units/nm->ft 1)
   :low -500})

(def carrier-elevation
  "SVG data for the elevation view of the carrier"
  (svg/g
   ;; TODO: Change this so that the zero point matches the location of
   ;; the carrier in BMS.
   :transform "scale(-1 1) translate(750 0)"
   (svg/defs
     (svg/path
      :id "carrier-outline-elevation"
      ;; The class attribute doesn't work correctly on SVG
      ;; elements, but we can use :attr to pull it off.
      :attr {:class "carrier-side"}
      :d "M-50 0
L0 60
L-1100 60
L-1100 0"))
   (svg/use
    :href "#carrier-outline-elevation")
   (svg/rect
    :attr {:class "carrier-side"}
    :x -850
    :y 60
    :width 150
    :height 90)
   (svg/rect
    :attr {:class "carrier-side"}
    :x -800
    :y 150
    :width 50
    :height 60)
   (svg/rect
    :attr {:class "carrier-side"}
    :x -850
    :y 150
    :width 25
    :height 40)))

(defn elevation-path
  [pass]
  (let [commands (cons "M" (repeat "L"))
        {:keys [frames pilot-id]} pass]
    (->> (map (fn [[t data] command]
                (log/debug "elevation-path" :data (map? data))
                (let [{:keys [::grading/slope
                              ::grading/distance
                              ::acmi/entities]} data
                      pilot (get entities pilot-id)
                      alt (-> pilot ::acmi/alt units/m->ft)]
                  (str command (log/spy distance) " " (log/spy alt) "\n")))
              frames
              commands)
         (interpose " ")
         (reduce str))))

(defn elevation
  "Draws the side view of the pass."
  []
  (let [{:keys [west east high low]} view-bounds]
    (svg/svg
     :viewBox (gstring/format "%d %d %d %d"
                              west
                              high
                              (- east west)
                              (- high low))
     :id "elevation"
     (svg/g
      :transform (gstring/format "scale(1 -1) translate(0 -%f)"
                                 (* 2 high))
      (svg/rect
       :attr {:class "sky"}
       :x west
       :y 0
       :width (- east west)
       :height high)
      (carrier-elevation)
      (svg/circle
       :attr {:class "zero-dot"}
       :cx 0
       :cy 0
       :r 20)
      (formula-of
       [selected-pass]
       (when selected-pass
         (svg/path
          :attr {:class "approach-path"}
          :d (elevation-path selected-pass))))))))

(defn coords
  "Returns the coordinates of entity in feet"
  [entity]
  (->> entity ((juxt ::acmi/u ::acmi/v)) (mapv units/m->ft)))

(defn plan-path
  [id frames]
  (log/debug :id id :frames (count frames))
  (let [e              (fn [f] (-> f acmi/entities (get id)))
        commands       (cons "M" (repeat "L"))]
    (->> (map (fn [frame command]
                (let [[x y] (-> frame (acmi/entity id) coords)]
                  (str command x " " y "\n")))
              frames
              commands)
         (interpose " ")
         (reduce str))))

(defmethod do! :viewBox
    [elem _ value]
    (if (= false value)
        (.removeAttribute elem "viewBox")
        (.setAttribute elem "viewBox" value)))

(def carrier-plan
  "SVG data for the plan view of the carrier"
  (svg/g
   ;; TODO: Change this so that the zero point matches the location of
   ;; the carrier in BMS.
   :transform "translate(-140 -750)"
   (svg/defs
     (svg/path
      :id "carrier-outline"
      ;; The class attribute doesn't work correctly on SVG
      ;; elements, but we can use :attr to pull it off.
      :attr {:class "carrier-top"}
      :d "M80 1100
L250 1100
L280 920
L280 350
L200 200
L180 0
L100 0
L80 200
L0 350
L0 920
L30 1100")
     (svg/clipPath
      :id "carrier-outline-clip"
      (svg/use :href "#carrier-outline")))
   (svg/use
    :href "#carrier-outline")
   (svg/g
    :clip-path "url(#carrier-outline-clip)"
    (svg/g
     :transform "rotate(-7 180 1100)"
     (svg/line
      :attr {:class "carrier-top-markings end"}
      :x1 "180"
      :y1 "1090"
      :x2 "100"
      :y2 "1090")
     (svg/line
      :attr {:class "carrier-top-markings"}
      :x1 "180"
      :y1 "1100"
      :x2 "180"
      :y2 "0")
     (svg/line
      :attr {:class "carrier-top-markings"}
      :x1 "100"
      :y1 "1100"
      :x2 "100"
      :y2 "0")
     (svg/line
      :attr {:class "carrier-top-markings middle"}
      :x1 "140"
      :y1 "1100"
      :x2 "140"
      :y2 "0")))))

(defn plan
  "Draws the top view of the pass."
  []
  (svg/svg
   :id "plan"
   :viewBox (let [{:keys [west east north south]} view-bounds]
              (gstring/format "%d %d %d %d"
                              west
                              north
                              (- east west)
                              (- south north)))
   (formula-of [selected-pass]
               (let [{:keys [carrier-id frames]} selected-pass
                     carrier (-> frames
                                 last
                                 (acmi/entity carrier-id))
                     [x y] (coords carrier)]
                 (svg/g
                  :transform (gstring/format "translate(%f,%f) rotate(-83)" x y)
                  (carrier-plan)
                  (svg/circle
                   :attr {:class "zero-dot"}
                   :cx x
                   :cy y
                   :r 20))))
   (formula-of [selected-pass]
               (when-let [{:keys [carrier-id pilot-id frames]} selected-pass]
                 (let [[x y] (-> frames first (acmi/entity carrier-id) coords)]
                   (svg/path :attr {:class "approach-path"}
                             :d (cell= (plan-path pilot-id frames))))))
   ))

(html
 (head
  (title "LSOBot")
  (link :href "style.css" :rel "stylesheet" :title "main" :type "text/css")
  (link :href "https://fonts.googleapis.com/css?family=Open+Sans+Condensed:300"
        :rel "stylesheet"
        :type "text/css"))
 (body
  (div :id "titlebar"
       (div :id "words"
            (span :id "title"
                  "LSOBot")
            (span :id "byline"
                  "by"
                  (a :href "http://firstfighterwing.com/VFW/member.php?893-Tyrant"
                     :target "_blank"
                     "Tyrant"))
            (span :id "helpstring"
                  "Help? Bug? Feature request? Click"
                  (a :href "help.html"
                     :target "_blank"
                     "here")
                  "."))
       (a :href "http://firstfighterwing.com"
          :target "_blank"
          (img :id "winglogo"
               :src "images/1stVFW_Insignia-64.png")))
  (button :click load-acmi "Load ACMI")
  (if-tpl loading?
    (img :id "spinner" :src "images/spinner.gif")
    (let [mt? (cell= (empty? passes))]
      (div
       (if-tpl mt?
         (div "No passes detected")
         [(table
           :id "passes"
           (thead (tr (td) (td "Carrier") (td "Pilot") (td "Pass time")))
           (tbody
            (for-tpl [{:keys [carrier-id pilot-id start index]} passes]
              (do
                (log/debug :index index
                           :carrier-id carrier-id
                           :pilot-id pilot-id)
                (tr
                 (td (input :type "radio"
                            :name "pass"
                            :click #(reset! selected-pass-index @index)
                            :checked (formula-of
                                      [selected-pass-index]
                                      (= selected-pass-index index))))
                 (td (cell= (property carrier-id "Name")))
                 (td (cell= (property pilot-id ::acmi/pilot)))
                 (td (cell= (time-str reference-time start))))))))])
       (elevation)
       (plan))))))
