(page "index.html"
  (:require [clojure.string :as str]
            [hoplon.svg :as svg]
            [goog.dom :as gdom]
            [goog.events :as gevents]
            [goog.string :as gstring]
            [goog.string.format]
            [goog.style :as gstyle]
            [cljs.core.async :as async
             :refer [<! >! timeout]]
            [lsobot.acmi :as acmi]
            [lsobot.grading :as grading]
            [lsobot.help :as help]
            [lsobot.svg-fix :as svg-fix]
            [lsobot.units :as units]
            [taoensso.timbre :as log
             :refer-macros (log trace debug info warn error fatal report
                                logf tracef debugf infof warnf errorf fatalf reportf
                                spy get-env log-env)])
  (:import [goog.events EventType])
  (:require-macros
   [cljs.core.async.macros :refer [go go-loop]]
   [lsobot.macros :refer [formula-of defformula]]))

(svg-fix/fix-svg!)

;;; Utilities

(defn time-str
  [acmi t]
  ;; For now we're just going to assume the reference time is midnight
  (let [{:keys [d h m s]} (units/s->dhms t)]
    (gstring/format "%02d/%02d:%02d:%02d" d h m (long s))))

(defn property
  [acmi id prop]
  (-> acmi ::acmi/frames last ::acmi/entities (get-in [id prop])))

;; Polyfill for !@#$!#$ Internet Explorer
(when-not (-> js/String .-prototype .-startsWith)
  (log/debug "Setting IE polyfill for String.startsWith")
  (-> js/String
      .-prototype
      .-startsWith
      (set! (fn [s pos]
              (let [pos* (or pos 0)]
                (this-as me
                  (= pos* (.indexOf me s pos*))))))))


;;; State

(defc show-debug? false)

(defc pass-parameters grading/default-parameters)

(defc acmi-name nil)

(defc acmi nil)

(defc loading? false)

(defc selected-pass nil)

(defc limit-displayed-passes? false)

(defn get-passes
  [acmi params]
  (->>  (for [[carrier-id pilot-passes] (grading/passes acmi params)
              [pilot-id assessments] pilot-passes
              assessment assessments]
          {:assessment assessment
           :carrier    (-> acmi ::acmi/frames last (acmi/entity carrier-id) ::acmi/name)
           :pilot      (-> acmi ::acmi/frames last (acmi/entity pilot-id) ::acmi/pilot)
           :start      (->> assessment ::grading/frames first ::acmi/t (time-str nil))})
        (sort-by (juxt :carrier :pilot :start))))

(defformula passes
  [acmi pass-parameters]
  (get-passes acmi pass-parameters))

(defn next-pass
  "Moves to the next pass in the list, if there is one."
  []
  (cond
    (empty? @passes) nil
    (nil? @selected-pass) (reset! selected-pass (first @passes))
    (= @selected-pass (last @passes)) nil
    :else (reset! selected-pass (->> @passes
                                     (drop-while #(not= @selected-pass %))
                                     second))))

(defn prev-pass
  "Moves to the previous pass in the list, if ther eis one"
  []
  (cond
    (empty? @passes) nil
    (nil? @selected-pass) (reset! selected-pass (last @passes))
    (= @selected-pass (first @passes)) nil
    :else (reset! selected-pass (->> @passes
                                     (take-while #(not= @selected-pass %))
                                     last))))

;;; Serialization

(defn load-acmi
  [_]
  (let [i (gdom/createElement "input")
        ch (async/chan)]
    (-> i .-type (set! "file"))
    (-> (gdom/getDocument) .-body (gdom/appendChild i))
    (gstyle/showElement i false)
    (-> i .-onchange (set! (fn [e]
                             (async/put! ch e)
                             (async/close! ch))))
    (.click i)
    (go
      (let [e (<! ch)]
        (when-let [file (aget (.. e -target -files) 0)]
          (let [reader (js/FileReader.)]
            (-> reader
                .-onload
                (set! #(do
                         (reset! loading? true)
                         (go
                           ;; Give the loading changes to take
                           (<! (async/timeout 100))
                           (let [contents (-> % .-target .-result)]
                             (dosync
                              (reset! acmi (acmi/read-acmi contents))
                              (reset! acmi-name (.-name file))
                              (reset! selected-pass
                                      (when (= 1 (count @passes))
                                        (first @passes)))
                              (reset! loading? false)
                              (reset! limit-displayed-passes? false)))))))
            (.readAsText reader file)))))))

;;; Help

(let [help-states (cell {})]
  (defelem help [{:keys []} contents]
    (let [id (str (gensym))
          content-id (str "content-" id)
          img-id (str "img-" id)]
      (div
       :class "help"
       (div
        :id content-id
        :fade-toggle (cell= (get help-states id))
        :class "content"
        :click #(swap! help-states assoc id false)
        (div :class "close-help" "X")
        contents)
       (div
        :id img-id
        :class "img"
        :click #(swap! help-states
                       (fn [hs]
                         (merge (zipmap (keys hs) (repeat false))
                                {id (not (get hs id))})))
        ;; TODO; Don't make the help go away if the place the mouse
        ;; has gone is the help content.
        ;; :mouseout (fn []
        ;;             (go (<! (async/timeout 1000))
        ;;                 (swap! help-states assoc id false)))
        "?")))))

(defn help-for
  [help-path]
  (help (or (get-in help/content help-path)
            (p "Help content has not yet been written for this feature."))))

;;; UI

(def urls
  {:tyrant "http://firstfighterwing.com/VFW/member.php?893-Tyrant"
   :shady "http://firstfighterwing.com/VFW/member.php?484-Shady"
   :flounder "http://firstfighterwing.com/VFW/member.php?217-Flounder"
   :drillin "http://firstfighterwing.com/VFW/member.php?133-Drillin"})

(def view-bounds
  {:west -1100
   :east 7000
   :north (units/nm->ft -0.25)
   :south (units/nm->ft 0.25)
   :high (units/nm->ft 0.35)
   :low -500
   :fast 5.5                            ; Degrees AOA
   :slow 10.5                           ; Degrees AOA
   ;;:aoa-aspect 6.7
   :aoa-aspect 3
   })

(def carrier-dimensions
  {:length 1100
   :x-offset -102
   :y-offset 300})

(defn carrier-elevation
  "SVG data for the elevation view of the carrier"
  [deck-height]
  (svg/g
   ;; TODO: Change this so that the zero point matches the location of
   ;; the landing point
   :transform (gstring/format "scale(-1 1) translate(%f -%f)"
                              (- (:length carrier-dimensions)
                                 (:y-offset carrier-dimensions))
                              (double deck-height))
   (svg/path
    :id "carrier-outline-elevation"
    ;; The class attribute doesn't work correctly on SVG
    ;; elements, but we can use :attr to pull it off.
    :attr {:class "carrier-side"}
    :d (gstring/format "M-50 0 L0 %f L%f %f L%f 0"
                       (double deck-height)
                       (- (:length carrier-dimensions))
                       (double deck-height)
                       (- (:length carrier-dimensions))))
   (svg/rect
    :attr {:class "carrier-side"}
    :x -850
    :y deck-height
    :width 150
    :height 90)
   (svg/rect
    :attr {:class "carrier-side"}
    :x -800
    :y 150
    :width 50
    :height deck-height)
   (svg/rect
    :attr {:class "carrier-side"}
    :x -850
    :y 150
    :width 25
    :height 40)))

(defn carrier-plan
  []
  "SVG data for the plan view of the carrier"
  (let [outline (svg/path
                 ;; The class attribute doesn't work correctly on SVG
                 ;; elements, but we can use :attr to pull it off.
                 :attr {:class "carrier-top"}
                 :d "M80 1100
L250 1100
L280 920
L280 350
L200 200
L180 0
L100 0
L80 200
L0 350
L0 920
L30 1100")]
    [(svg/defs
       ;; The carrier outline, relative to an origin at the port aft (is
       ;; this right?) corner, with X increasing to starboard, and Y
       ;; increasing forward
       (svg/clipPath
        :id "carrier-outline-clip"
        ;; Much as I would like to employ an SVG <use> element here,
        ;; rather than repeat myself from earlier, it doesn't render
        ;; right in Firefox or Safari
        (svg/path
         :d "M80 1100
L250 1100
L280 920
L280 350
L200 200
L180 0
L100 0
L80 200
L0 350
L0 920
L30 1100")))
     (svg/g
      :transform (gstring/format "rotate(-83) translate(%f %f)"
                                 (:x-offset carrier-dimensions)
                                 (- (:y-offset carrier-dimensions)
                                    (:length carrier-dimensions)))
      outline
      (svg/g
       :clip-path "url(#carrier-outline-clip)"
       (svg/g
        :transform (gstring/format "rotate(-7 180 1100)")
        (svg/line
         :attr {:class "carrier-top-markings end"}
         :x1 "180"
         :y1 "1090"
         :x2 "100"
         :y2 "1090")
        (svg/line
         :attr {:class "carrier-top-markings"}
         :x1 "180"
         :y1 "1100"
         :x2 "180"
         :y2 "0")
        (svg/line
         :attr {:class "carrier-top-markings"}
         :x1 "100"
         :y1 "1100"
         :x2 "100"
         :y2 "0")
        (svg/line
         :attr {:class "carrier-top-markings middle"}
         :x1 "140"
         :y1 "1100"
         :x2 "140"
         :y2 "0"))))]))

(def pitch-exaggeration 1)

(defn deviation-classes
  [base deviation]
  (let [{:keys [::grading/direction ::grading/degree]} deviation]
    (str base
         " "
         (when direction (name direction))
         " "
         (when degree (name degree)))))

(def aoa-smoothing 0.9)

(defn aoa-path
  "Returns SVG data that shows the AOA data"
  [params scale pass]
  (svg/g
   :attr {:class "aoa-data"}
   (let [frames (->> pass :assessment ::grading/frames)]
     (for [frame frames
           :let [{:keys [::grading/aoa ::grading/t ::grading/downrange]} frame
                 {:keys [::grading/value ::grading/deviation]} aoa]
           :when (and aoa (pos? downrange))]
       (svg/circle
        :attr {:class (deviation-classes "aoa-value " deviation)
               :t t}
        :transform (gstring/format "translate(%f %f)"
                                   downrange
                                   (* scale value))
        :cx 0
        :cy 0
        :r 25)))))

(def elevation-exaggeration 4)

(defn elevation-path
  [params pass]
  (svg/g
   :attr {:class "approach-path"}
   (for [frame (-> pass :assessment ::grading/frames)]
     (let [{:keys [::grading/glideslope
                   ::grading/hook-pos
                   ::acmi/t]} frame
           [_ downrange height] hook-pos
           {:keys [::grading/value ::grading/deviation]} glideslope]
       [(svg/circle
         :attr {:glideslope value
                :hook (::grading/hook-pos frame)
                :pitch (::grading/pitch frame)
                :height height
                :t t
                :class (deviation-classes "glideslope-data" deviation)}
         :cx downrange
         :cy (* elevation-exaggeration height)
         :r 25)
        (if (neg? downrange)
          []
          (let [aoa (-> frame ::grading/aoa ::grading/value)]
            (svg/circle
             :attr {:class (deviation-classes "aoa-deviation"
                                              (-> frame
                                                  ::grading/aoa
                                                  ::grading/deviation))}
             :cx downrange
             :cy (+ (* 100 (- aoa (-> params :aoa :ideal)))
                    (* elevation-exaggeration height))
             :r 10)))]))))

(let [angular-exaggeration 2
      x1 (units/deg->rad 4)
      x2 (units/deg->rad 10)]
  (defn exaggerate-angle
    "Make small angles bigger."
    ([rad]
     (cond
       (< (Math/abs rad) x1) (* angular-exaggeration rad)
       (< (Math/abs rad) x2) (-> rad
                                 Math/abs
                                 (- x1)
                                 (* (/ (- x2 (* angular-exaggeration x1))
                                       (- x2 x1)))
                                 (+ (* angular-exaggeration x1))
                                 (* (/ rad (Math/abs rad))))
       :else rad))
    ([x y]
     (let [r (Math/sqrt (+ (* x x) (* y y)))
           ax (Math/abs x)
           ay (Math/abs y)
           theta (Math/atan2 ay ax)
           theta' (exaggerate-angle theta)
           x' (* r (Math/cos theta'))
           y' (* r (Math/sin theta'))]
       ;; Sign of coordinates should match original signs
       [(* x' (/ x ax))
        (* y' (/ y ay))]))))

(defn plan-path
  [params pass]
  (svg/g
   :attr {:class "approach-path"}

   (for [frame (-> pass :assessment ::grading/frames)]
     (let [{:keys [::grading/lineup
                   ::grading/hook-pos
                   ::grading/speed
                   ::acmi/t]} frame
           [crosstrack-error downrange height] hook-pos
           {:keys [::grading/value ::grading/deviation]} lineup
           [downrange* crosstrack*] (exaggerate-angle downrange crosstrack-error)]
       ;; TODO: Exaggerate the angle to make errors more obvious
       (svg/circle
        :attr {:lineup value
               :t t
               :speed speed
               :class (deviation-classes "lineup-data" deviation)}
        :cx (if (pos? downrange) downrange* downrange)
        :cy (if (pos? downrange) crosstrack* crosstrack-error)
        :r 25)))))

(defn zones
  "Draw the lines that show range and zones, with their labels."
  [params y1 y2 zone-label-y text-transform class]
  (let [zones [:start :mid :in-close]
        zone-starts (mapv #(-> params :zones % :from) zones)
        zone-ends  (mapv #(-> params :zones % :to) zones)
        zone-ranges (into (set zone-starts) zone-ends)
        all-ranges (->> (range 0 6001 1500)
                        (into zone-ranges)
                        sort)]
    (svg/g
     :attr {:class "zone-markings"}
     (for [x all-ranges]
       [(svg/line
         :attr {:class (str class " range guideline" (when (zone-ranges x) " zone"))}
         :x1 x
         :y1 y1
         :x2 x
         :y2 y2)
        (svg/text
         :transform text-transform
         :attr {:class (str class " axis-label range")}
         :x (+ x 20)
         :y 0
         (str x))])
     (for [zone zones
           :let [from (-> params :zones zone :from)
                 to (-> params :zones zone :to)
                 midpoint (/ (+ from to) 2)]]
       (svg/text
        :transform text-transform
        :attr {:class (str class " axis-label range zone")}
        :x (- midpoint 60)
        :y zone-label-y
        (zone {:start    "X"
               :mid      "IM"
               :in-close "IC"})))
     (let [ar-start (-> params :zones :in-close :to)
           {:keys [ramp-to-1-wire wire-interval]} params
           ar-end 0
           midpoint (/ (+ ar-start ar-end) 2)]
       (svg/text
        :transform text-transform
        :attr {:class (str class " axis-label range zone")}
        :x (- midpoint 60)
        :y zone-label-y
        "AR")))))

(def elevation
  "Draws the side view of the pass."
  (formula-of
   [pass-parameters selected-pass]
   (let [{:keys [west east high low]} view-bounds
         [x y z] (:landing-point (log/spy pass-parameters))]
     (div
      :class "svg-container"
      :css {"padding-bottom" (-> (- high low)
                                 (/ (- east west))
                                 (* 100.0)
                                 (str "%"))}
      (svg/svg
       :attr {:class "graph"
              "xmlns" "http://www.w3.org/2000/svg"}
       :viewBox (gstring/format "%d %d %d %d"
                                west
                                (- high z)
                                (- east west)
                                (- high low))
       :id "elevation"
       (svg/g
        :transform (gstring/format "scale(1 -1) translate(0 %f)"
                                   (* -2 high))
        (svg/rect
         :attr {:class "sky"}
         :x west
         :y (- z)
         :width (- east west)
         :height (+ (* 2 z) high))
        (carrier-elevation z)
        (zones pass-parameters
               low
               (+ high z)
               (- (- (* elevation-exaggeration z)) high)
               (gstring/format "scale(1 -1) translate(0 %f)"
                               (- (+ low z 50)))
               "elevation")
        ;; Colored glideslope guidelines
        (let [params (:glideslope pass-parameters)
              guideline (fn [angle class tx]
                          [(svg/line
                            :attr {:class (str "elevation guideline glideslope "
                                               class)}
                            :transform (gstring/format "translate(%f 0) rotate(%f)"
                                                       tx
                                                       (* angle elevation-exaggeration))
                            :x1 0
                            :y1 0
                            :x2 (* 2 east)
                            :y2 0)
                           (svg/text
                            :transform (gstring/format "translate(%f 0) rotate(%f) scale(1 -1)"
                                                       tx
                                                       (* angle elevation-exaggeration))
                            :attr {:class (str "axis-label elevation glideslope " class)}
                            :x (- east 500)
                            :y -20
                            (str angle "°"))])]
          (svg/g
           (guideline (:ideal params) "ideal" 0)
           (for [[k1 m] (select-keys params [:good :minor :major])
                 [k2 v] (select-keys m [:low :high])
                 :let [class (str (name k1) " " (name k2))
                       tx (-> pass-parameters
                              :landing-window
                              second
                              (/ 2))]]
             (guideline v class (if (= k2 :low)
                                  tx
                                  (- tx))))))
        ;; Guidelines for assessment zones/phases
        (svg/line
         :attr {:class "elevation guideline zone"}
         :x1 west
         :y1 (* (- 450 z) elevation-exaggeration)
         :x2 east
         :y2 (* (- 450 z) elevation-exaggeration))
        (svg/text
         :transform "scale(1 -1)"
         :attr {:class "axis-label elevation height zone"}
         :x (+ west 20)
         :y (* (- z 460) elevation-exaggeration)
         "450")
        ;; A nil stops rendering. But an empty collection does not
        (if selected-pass
          (elevation-path pass-parameters selected-pass)
          [])
        (svg/circle
         :attr {:class "landing-point-dot"}
         :cx 0
         :cy 0
         :r 20)
        ))))))

(def plan
  "Draws the top view of the pass."
  (let [{:keys [west east north south]} view-bounds]
    (div
     :class "svg-container"
     :css {"padding-bottom" (-> (- south north)
                                (/ (- east west))
                                (* 100.0 )
                                (str "%"))}
     (svg/svg
      :attr {:class "graph"
             "xmlns" "http://www.w3.org/2000/svg"}
      :id "plan"
      :viewBox (gstring/format "%d %d %d %d"
                               west
                               north
                               (- east west)
                               (- south north))
      (carrier-plan)
      (svg/line
       :attr {:class "plan angle zero guideline"}
       :x1 west
       :y1 0
       :x2 east
       :y2 0)
      (formula-of
       [pass-parameters]
       (svg/g
        (zones pass-parameters
               north
               south
               (+ (- north south) 200)
               (gstring/format "translate(0 %f)" (- south 50))
               "plan")
        (let [params (:lineup pass-parameters)]
          (for [[k1 m] (select-keys params [:good :minor :major])
                [k2 v] (select-keys m [:low :high])]
            (let [angle (-> v units/deg->rad exaggerate-angle units/rad->deg)
                  ty (-> pass-parameters
                         :landing-window
                         first
                         (/ 2)
                         (* (if (= k2 :low)
                              -1
                              1)))]
              [(svg/line
                :transform (gstring/format "translate(0 %f) rotate(%f)" ty angle)
                :attr {:class (str "plan angle guideline "
                                   (name k1) " " (name k2))}
                :x1 0
                :y1 0
                :x2 (* east 2)
                :y2 0)
               (svg/text
                :transform (gstring/format "translate(0 %f) rotate(%f)" ty angle)
                :attr {:class (str "axis-label plan angle "
                                   (name k1) " " (name k2))}
                :x (- east 500)
                :y -20
                (str (.toFixed v 1) "°"))])))))
      (svg/g
       ;; We need to invert the y axis because of the way the coordinate
       ;; systems interact: in landing space, crosstrack error increases
       ;; to the right
       :transform "scale(1 -1)"
       (formula-of
        [selected-pass pass-parameters]
        (when selected-pass
          (plan-path (:lineup pass-parameters) selected-pass)))
       (svg/circle
        :attr {:class "landing-point-dot"}
        :cx 0
        :cy 0
        :r 20))))))

(def titlebar
  (div :id "titlebar"
       (div :id "words"
            (span :id "title"
                  "LSOBot")
            (span :id "byline"
                  "by"
                  (a :href (urls :tyrant)
                     :target "_blank"
                     "Tyrant")
                  "and"
                  (a :href "#"
                     :data-featherlight "#credits"
                     "Team LSOBot"))
            (span :id "helpstring"
                  "Help? Bug? Feature request? Click"
                  (a :href "help.html"
                     :target "_blank"
                     "here")
                  "."))
       (a :href "http://firstfighterwing.com"
          :target "_blank"
          (img :id "winglogo"
               :src "images/1stVFW_Insignia-64.png"))))

(def result-text
  {:trap "Trap"
   :waveoff "Waveoff"
   :ramp-strike "Ramp Strike"
   :bolter "Bolter"})

(def symbol-mapping
  {::grading/aoa-assessment        {:low  "F"
                                    :high "S"}
   ::grading/glideslope-assessment {:low  "LO"
                                    :high "H"}
   ::grading/lineup-assessment     {:low  "LUL"
                                    :high "LUR"}})

(def phase-symbol
  {::grading/start "X"
   ::grading/mid "IM"
   ::grading/in-close "IC"
   ::grading/at-ramp "AR"})

(defn assessment-mark
  ([dimension deviation] (assessment-mark dimension deviation nil))
  ([dimension deviation phase]
   (let [{:keys [::grading/degree ::grading/direction]} deviation]
     (if-not direction
       ""
       (let [mark (-> symbol-mapping dimension direction)
             mark (if phase
                    (str mark (phase-symbol phase))
                    mark)]
         (if (#{:ideal :good} degree)
           ""
           mark))))))

(defn assessment-symbol
  ([dimension deviation]
   (assessment-symbol dimension deviation nil))
  ([dimension deviation phase]
   (span
    :class ["assessment-symbol"
            (or (some-> deviation ::grading/degree name) "")
            (or (some-> deviation ::grading/direction name) "")
            (or (some-> phase name) "")]
    (assessment-mark dimension deviation phase))))

(defn not-implemented-cell
  [assessment]
  (span :class "not-implemented"))

(defn grade-cell
  [assessment]
  (case (log/spy (-> assessment ::grading/grade))
    ::grading/bolter "B"
    ::grading/waveoff "WO"
    ::grading/ok+ (span :class "perfect" "OK")
    ::grading/ok "OK"
    ::grading/fair "(OK)"
    ::grading/none "-"
    ::grading/cut-pass "C"
    ""))

(defn score-cell
  [assessment]
  (-> assessment
      ::grading/grade
      grading/grades
      (:score "")))

(defn aw-cell
  [assessment]
  (for [dimension [::grading/glideslope-assessment
                   ::grading/lineup-assessment
                   ::grading/aoa-assessment]
        deviation (-> assessment ::all-the-way dimension)]
    (span
     :class ["assessment-symbol"
             (or (some-> deviation ::grading/degree name) "")
             (or (some-> deviation ::grading/direction name) "")]
     (assessment-mark dimension deviation nil))))

(defn glideslope-and-speed-cell
  [phase assessment]
  (for [dimension [::grading/glideslope-assessment
                   ::grading/aoa-assessment]]
    (let [deviation (get-in assessment [phase dimension])]
     (assessment-symbol dimension deviation))))

(defn x-cell
  [assessment]
  (glideslope-and-speed-cell ::grading/start assessment))

(defn im-cell
  [assessment]
  (glideslope-and-speed-cell ::grading/mid assessment))

(defn ic-cell
  [assessment]
  (glideslope-and-speed-cell ::grading/in-close assessment))

(defn ar-cell
  [assessment]
  (when (#{:trap :bolter} (::grading/result assessment))
    (glideslope-and-speed-cell ::grading/at-ramp assessment)))

(def power-cell not-implemented-cell)
(def att-cell not-implemented-cell)
(defn lineup-and-wing-cell
  [assessment]
  (for [phase (into [::grading/start ::grading/mid ::grading/in-close]
                    (when (#{:trap :bolter} (::grading/result assessment))
                      [::grading/at-ramp]))]
    (let [deviation (get-in assessment [phase ::grading/lineup-assessment])]
      (assessment-symbol ::grading/lineup-assessment deviation phase))))

(defn wire-cell
  [assessment]
  (case (-> assessment ::grading/result)
    :bolter "B"
    :waveoff "WO"
    :trap (-> assessment ::grading/wire)
    ""))

(defn remarks-cell
  [assessment]
  (span :class "remark"
        (case (-> assessment ::grading/result)
          :trap "Trap"
          :ramp-strike "Ramp strike"
          "")))

(defn consolidate
  "Looks for ways to consolidate assessments into the 'AW' column."
  [assessment]
  (let [phases (if (= :waveoff (::grading/result assessment))
                 [::grading/start ::grading/mid ::grading/in-close]
                 [::grading/start ::grading/mid ::grading/in-close ::grading/at-ramp])
        match? (fn [degree direction deviation]
                 (= [degree direction]
                    [(::grading/degree deviation) (::grading/direction deviation)]))
        common (for [direction [:high :low]
                     degree [:ideal :good :minor :major :unacceptable]
                     dimension [::grading/aoa-assessment
                                ::grading/lineup-assessment
                                ::grading/glideslope-assessment]
                     :when (every? (fn [phase]
                                     (->> assessment
                                          phase
                                          dimension
                                          (match? degree direction)))
                                   phases)]
                 [dimension degree direction])
        assessment* (->> common
                         (reduce (fn [assessment [dimension degree direction]]
                                   (reduce (fn [assessment phase]
                                             (update
                                              assessment
                                              phase
                                              dissoc
                                              dimension))
                                           assessment
                                           phases))
                                 assessment))]
    (reduce (fn [assessment [dimension degree direction]]
              (update-in assessment
                         [::all-the-way dimension]
                         conj
                         {::grading/degree degree
                          ::grading/direction direction}))
            assessment*
            common)))

(defn assessment
  "Returns UI for the assessment section"
  [passes selected-pass limit-displayed-passes?]
  (table
   :id "assessments"
   (thead
    (tr
     :class "header-1"
     (th
      :class "toggle-button"
      :colspan 4
      (let [limit-cell limit-displayed-passes?]
        [(div :id "scoresheet-help" (help-for [:scoresheet]))
         (formula-of
          [passes selected-pass limit-displayed-passes?]
          (button
           :id "limit-pass-display"
           :toggle (and passes selected-pass (< 1 (count passes)))
           :click #(reset! limit-cell (not limit-displayed-passes?))
           (if limit-displayed-passes?
             "Show all passes"
             "Only show selected pass")))]))
     (th :class "gs-speed-errors" :colspan 7 "Glideslope and Speed Errors")
     (th :class "control-errors" :colspan 2 "Control Errors")
     (th :class "lineup-and-wing" :rowspan 2 "Lineup " (br) "& Wing")
     (th :class "wire" :rowspan 2 "Wire #")
     (th :class "remarks" :rowspan 2 "Remarks"))
    (tr
     :class "header-2"
     (th :class "select" "")
     (th :class "carrier"  "Carrier")
     (th :class "pilot"  "Pilot")
     (th :class "start" "Time")
     (th :class "grade" "Grade")
     (th :class "score" "Score")
     (th :class "aw" "AW")
     (th :class "x" "X")
     (th :class "im" "IM")
     (th :class "ic" "IC")
     (th :class "ar" "AR")
     (th :class "power" "Power")
     (th :class "att" "ATT")))
   (tbody
    (let [selected-pass-cell selected-pass]
      (formula-of
       [passes selected-pass limit-displayed-passes?]
       (if (empty? passes)
         (tr (td :class "none-loaded" :colspan 16 "No Passes Detected"))
         (for [pass passes
               :let [{:keys [carrier pilot start assessment]} pass
                     assessment* (consolidate assessment)
                     _ (log/debug "grade"
                                  :consolidated (::grading/grade assessment*)
                                  :normal (::grading/grade assessment))
                     td+ (fn [class cell-f]
                           (td :class (str class " assessment-cell")
                               (cell-f assessment*)))]]
           (tr
            :css {:display (if (or (not selected-pass)
                                   (not limit-displayed-passes?)
                                   (= selected-pass pass))
                             "table-row"
                             "none")}
            (td+ "select"
                 (constantly
                  (input :type "radio"
                         :name "pass"
                         :click #(reset! selected-pass-cell pass)
                         :checked (= selected-pass pass))))
            (td+ "carrier"
                 (constantly carrier))
            (td+ "pilot"
                 (constantly pilot))
            (td+ "start"
                 (constantly start))
            (td+ "grade" grade-cell)
            (td+ "score" score-cell)
            (td+ "aw" aw-cell)
            (td+ "x" x-cell)
            (td+ "im" im-cell)
            (td+ "ic" ic-cell)
            (td+ "ar" ar-cell)
            (td+ "power" power-cell)
            (td+ "att" att-cell)
            (td+ "lineup-and-wing" lineup-and-wing-cell)
            (td+ "wire" wire-cell)
            (td+ "remarks" remarks-cell)))))))))

(def keymap {49 :one
             97 :a
             98 :b
             99 :c
             100 :d
             108 :l
             110 :n
             112 :p
             78 :N
             80 :P
             ;; TODO: The rest
             })

(defn scroll-to
  [id]
  (let [body (js/jQuery "body,html")
        elem (js/jQuery (gdom/getElement id))]
    (.animate body (clj->js {:scrollTop (.-top (.offset elem))}))))

(def key-action {:a #(scroll-to "aoa")
                 :b #(scroll-to "elevation")
                 :c #(scroll-to "plan")
                 ;; :d #(swap! show-debug? not)
                 :l #(load-acmi nil)
                 :n next-pass
                 :p prev-pass
                 ;;:one #(swap! limit-displayed-passes? not)
                 })

(defn keypress
  [e]
  (log/debug "Key pressed" :keycode (.-keyCode e))
  (when-let [action (some-> e .-keyCode keymap key-action)]
    (action)))

(def credits
  "The credits lightbox"
  (div
   :id "credits-wrapper"
   :css {:display "none"}
   (div
    :class ".lightbox"
    :id "credits"
    (h1 "Credits")
    (div
     :id "credits-body"
     (img :class "squadron-emblem" :src "images/401st.png")
     (table
      (tr (td :class "person" (a :href (urls :tyrant) "Tyrant"))
          (td "Design and implementation"))
      (tr (td :class "person" (a :href (urls :flounder) "Flounder"))
          (td "Concept, testing, project management"))
      (tr (td :class "person" (a :href (urls :shady) "Shady"))
          (td "Concept, testing, project management"))
      (tr (td :class "person" (a :href (urls :drillin) "Drillin"))
          (td "CO, 401st VFS")))
     (p "Team LSOBot would also like to thank the members of the 1st VFW and especially of the 401st VFS for their help and support during development.")))))

(html
 (head
  (title "LSOBot")
  (link :rel "Shortcut Icon" :href "images/favicon.ico" :type "image/x-icon")
  (link :href "//cdn.rawgit.com/noelboss/featherlight/1.5.0/release/featherlight.min.css"
        :type "text/css"
        :rel "stylesheet")
  (link :href "style.css" :rel "stylesheet" :title "main" :type "text/css")
  (link :href "https://fonts.googleapis.com/css?family=Open+Sans+Condensed:300"
        :rel "stylesheet"
        :type "text/css")
  (link :href "https://fonts.googleapis.com/css?family=Kalam"
        :rel "stylesheet"
        :type "text/css")
)
 (body
  :id "body"
  ;;:keypress keypress
  titlebar
  (if-tpl loading?
    [(div
      :id "loading-placeholder"
      (span
       :id "loading-placeholder-message"
       "Loading...")
      (img :id "spinner" :src "images/spinner.gif"))]
    (button :id "load-button" :click load-acmi "Load ACMI"))
  (formula-of
   [acmi]
   (if-not acmi
     (div "No ACMI file loaded")
     (div "Loaded ACMI: " acmi-name)))
  (assessment passes selected-pass limit-displayed-passes?)
  (div
   :id "graphs"
   (div
    (div
     :class "graph-label-wrapper"
     (div :class "graph-label"
          "Glideslope and AoA")
     (help-for [:glideslope]))
    elevation)
   (div
    (div
     :class "graph-label-wrapper"
     (div :class "graph-label"
          "Lineup")
     (help-for [:lineup]))
    plan))
  ;; Debug support
  #_(button
   :click #(swap! show-debug? not)
   (cell= (if show-debug?
            "Hide debug controls"
            "Show debug controls")))
  #_(let [pass-parameters-cell pass-parameters]
    (formula-of
     [pass-parameters]
     (let [temp-parameters (cell pass-parameters)]
       (fieldset
        :toggle show-debug?
        :id "debug-weights"
        (legend "Assessment Weights")
        (table
         (thead
          (tr
           (th "Param")
           (th "Default")
           (th "Current")
           (th "Change to")))
         (tbody
          (for [[k label] [[:start "Zone Start"]
                           [:end "Zone End"]
                           [:ideal "Ideal"]
                           [:good "Good"]
                           [:minor "Minor Deviation"]
                           [:major "Major Deviation"]
                           [:unacceptable "Unacceptable Deviation"]]
                :let [path [:weights k]
                      id (str (gensym))]]
            (tr
             (td label)
             (td (str (get-in grading/default-parameters path)))
             (td (cell= (get-in pass-parameters-cell path)))
             (td (input :id id
                        :type "text"
                        :value (cell= (get-in temp-parameters path))
                        :change #(swap! temp-parameters assoc-in path (js/Number @%))))))))
        (button
         ;; This dosync is a filthy hack, but I had to do it to make things
         ;; work right.
         :click #(dosync (reset! pass-parameters-cell @temp-parameters))
         "Apply")))))
  credits
  (script :src "//cdn.rawgit.com/noelboss/featherlight/1.5.0/release/featherlight.min.js"
          :type "text/javascript"
          :charset "utf-8"))
 )

;; Keypresses handler was getting registered more than once when the
;; code would reload, which is super annoying.
(let [body (gdom/getElement "body")]
  (gevents/removeAll body EventType.KEYPRESS)
  (gevents/listen body EventType.KEYPRESS keypress))

(log/merge-config! {:ns-blacklist ["hoplon.app-pages._index_DOT_html"]})

(comment
  ;; This draw the table of passes. Might use it again
  (table
   :id "passes"
   (thead (tr (td) (td "Carrier") (td "Pilot") (td "Pass time")))
   (tbody
    (for-tpl [{:keys [carrier-id pilot-id start index]} passes]
      (do
        (log/debug :index index
                   :carrier-id carrier-id
                   :pilot-id pilot-id)
        (tr
         (td (input :type "radio"
                    :name "pass"
                    :click #(reset! selected-pass-index @index)
                    :checked (formula-of
                              [selected-pass-index]
                              (= selected-pass-index index))))
         (td (cell= (property carrier-id ::acmi/name)))
         (td (cell= (property pilot-id ::acmi/pilot)))
         (td (cell= (time-str reference-time start))))))))
  )
