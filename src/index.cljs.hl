(page "index.html"
  (:require [clojure.string :as str]
            [goog.dom :as gdom]
            [goog.events :as gevents]
            [goog.string :as gstring]
            [goog.string.format]
            [goog.style :as gstyle]
            [cljs.core.async :as async
             :refer [<! >! timeout]]
            [lsobot.acmi :as acmi]
            [lsobot.grading :as grading]
            [lsobot.units :as units]
            [hoplon.svg :as svg]
            [taoensso.timbre :as log
             :refer-macros (log trace debug info warn error fatal report
                                logf tracef debugf infof warnf errorf fatalf reportf
                                spy get-env log-env)])
  (:import [goog.events EventType])
  (:require-macros
   [cljs.core.async.macros :refer [go go-loop]]
   [lsobot.macros :refer [formula-of defformula]]))

;;; State

(defc pass-parameters grading/default-parameters)

(defc acmi nil)

(defc loading? false)

(defc selected-pass nil)

(defc limit-displayed-passes? false)

(defn get-passes
  [acmi params]
  (->>  (for [[carrier-id pilot-passes] (grading/passes acmi params)
              [pilot-id assessments] pilot-passes
              assessment assessments]
          {:assessment assessment
           :carrier-id carrier-id
           :start      (-> assessment ::grading/frames first ::acmi/t)
           :pilot-id   pilot-id})
        (map-indexed (fn [index m]
                       (assoc m :index index)))))

(defformula passes
  [acmi pass-parameters]
  (get-passes acmi pass-parameters))

(defformula final-entities
  [acmi]
  (-> acmi
      ::acmi/frames
      last
      second
      ::acmi/entities))

(defn next-pass
  "Moves to the next pass in the list, if there is one."
  []
  (cond
    (empty? @passes) nil
    (nil? @selected-pass) (reset! selected-pass (first @passes))
    (= @selected-pass (last @passes)) nil
    :else (reset! selected-pass (->> @passes
                                     (drop-while #(not= @selected-pass %))
                                     second))))

(defn prev-pass
  "Moves to the previous pass in the list, if ther eis one"
  []
  (cond
    (empty? @passes) nil
    (nil? @selected-pass) (reset! selected-pass (last @passes))
    (= @selected-pass (first @passes)) nil
    :else (reset! selected-pass (->> @passes
                                     (take-while #(not= @selected-pass %))
                                     last))))

;;; Utilities

(defn time-str
  [acmi t]
  ;; For now we're just going to assume the reference time is midnight
  (let [s (mod t 60)
        t (long (/ t 60))
        m (mod t 60)
        t (long (/ t 60))
        h (mod t 24)
        d (long (/ t 24))]
    (gstring/format "%02d/%02d:%02d:%02d" (inc d) h m s)))

(defn property
  [acmi id prop]
  (-> acmi ::acmi/frames last ::acmi/entities (get-in [id prop])))

;;; Serialization

(defn load-acmi
  [_]
  (let [i (gdom/createElement "input")
        ch (async/chan)]
    (-> i .-type (set! "file"))
    (-> (gdom/getDocument) .-body (gdom/appendChild i))
    (gstyle/showElement i false)
    (-> i .-onchange (set! (fn [e]
                             (async/put! ch e)
                             (async/close! ch))))
    (.click i)
    (go
      (let [e (<! ch)]
        (when-let [file (aget (.. e -target -files) 0)]
          (let [reader (js/FileReader.)]
            (-> reader
                .-onload
                (set! #(do
                         (reset! loading? true)
                         (go
                           ;; Give the loading changes to take
                           (<! (async/timeout 100))
                           (let [contents (-> % .-target .-result)]
                             (dosync
                              (reset! acmi (acmi/read-acmi contents))
                              (reset! selected-pass
                                      (when (= 1 (count @passes))
                                        (first @passes)))
                              (reset! loading? false)
                              (reset! limit-displayed-passes? false)))))))
            (.readAsText reader file)))))))

;;; UI

(defmethod do! :viewBox
  [elem _ value]
  (if (= false value)
    (.removeAttribute elem "viewBox")
    (.setAttribute elem "viewBox" value)))

(defmethod do! :preserveAspectRatio
  [elem _ value]
  (if (= false value)
    (.removeAttribute elem "preserveAspectRatio")
    (.setAttribute elem "preserveAspectRatio" value)))

(def view-bounds
  {:west -1100
   :east 7000
   :north (units/nm->ft -0.25)
   :south (units/nm->ft 0.25)
   :high (units/nm->ft 0.35)
   :low -500
   :fast 5.5                            ; Degrees AOA
   :slow 10.5                           ; Degrees AOA
   ;;:aoa-aspect 6.7
   :aoa-aspect 3
   })

(def carrier-dimensions
  {:length 1100
   :x-offset -102
   :y-offset 300})

(defn carrier-elevation
  "SVG data for the elevation view of the carrier"
  [deck-height]
  (svg/g
   ;; TODO: Change this so that the zero point matches the location of
   ;; the landing point
   :transform (gstring/format "scale(-1 1) translate(%f -%f)"
                              (- (:length carrier-dimensions)
                                 (:y-offset carrier-dimensions))
                              (double deck-height))
   (svg/path
    :id "carrier-outline-elevation"
    ;; The class attribute doesn't work correctly on SVG
    ;; elements, but we can use :attr to pull it off.
    :attr {:class "carrier-side"}
    :d (gstring/format "M-50 0 L0 %f L%f %f L%f 0"
                       (double deck-height)
                       (- (:length carrier-dimensions))
                       (double deck-height)
                       (- (:length carrier-dimensions))))
   (svg/rect
    :attr {:class "carrier-side"}
    :x -850
    :y deck-height
    :width 150
    :height 90)
   (svg/rect
    :attr {:class "carrier-side"}
    :x -800
    :y 150
    :width 50
    :height deck-height)
   (svg/rect
    :attr {:class "carrier-side"}
    :x -850
    :y 150
    :width 25
    :height 40)))

(defn carrier-plan
  []
  "SVG data for the plan view of the carrier"
  (let [outline (svg/path
                 ;; The class attribute doesn't work correctly on SVG
                 ;; elements, but we can use :attr to pull it off.
                 :attr {:class "carrier-top"}
                 :d "M80 1100
L250 1100
L280 920
L280 350
L200 200
L180 0
L100 0
L80 200
L0 350
L0 920
L30 1100")]
    [(svg/defs
       ;; The carrier outline, relative to an origin at the port aft (is
       ;; this right?) corner, with X increasing to starboard, and Y
       ;; increasing forward
       (svg/clipPath
        :id "carrier-outline-clip"
        ;; Much as I would like to employ an SVG <use> element here,
        ;; rather than repeat myself from earlier, it doesn't render
        ;; right in Firefox or Safari
        (svg/path
         :d "M80 1100
L250 1100
L280 920
L280 350
L200 200
L180 0
L100 0
L80 200
L0 350
L0 920
L30 1100")))
     (svg/g
      :transform (gstring/format "rotate(-83) translate(%f %f)"
                                 (:x-offset carrier-dimensions)
                                 (- (:y-offset carrier-dimensions)
                                    (:length carrier-dimensions)))
      outline
      (svg/g
       :clip-path "url(#carrier-outline-clip)"
       (svg/g
        :transform (gstring/format "rotate(-7 180 1100)")
        (svg/line
         :attr {:class "carrier-top-markings end"}
         :x1 "180"
         :y1 "1090"
         :x2 "100"
         :y2 "1090")
        (svg/line
         :attr {:class "carrier-top-markings"}
         :x1 "180"
         :y1 "1100"
         :x2 "180"
         :y2 "0")
        (svg/line
         :attr {:class "carrier-top-markings"}
         :x1 "100"
         :y1 "1100"
         :x2 "100"
         :y2 "0")
        (svg/line
         :attr {:class "carrier-top-markings middle"}
         :x1 "140"
         :y1 "1100"
         :x2 "140"
         :y2 "0"))))]))

(def pitch-exaggeration 1)

(defn deviation-classes
  [base deviation]
  (let [{:keys [::grading/direction ::grading/degree]} deviation]
    (str base
         " "
         (when direction (name direction))
         " "
         (when degree (name degree)))))

(def aoa-smoothing 0.9)

(defn aoa-path
  "Returns SVG data that shows the AOA data"
  [params scale pass]
  (svg/g
   :attr {:class "aoa-data"}
   (let [frames (->> pass :assessment ::grading/frames)]
     (for [frame frames
           :let [{:keys [::grading/aoa ::grading/t ::grading/downrange]} frame
                 {:keys [::grading/value ::grading/deviation]} aoa]
           :when (and aoa (pos? downrange))]
       (svg/circle
        :attr {:class (deviation-classes "aoa-value " deviation)
               :t t}
        :transform (gstring/format "translate(%f %f)"
                                   downrange
                                   (* scale value))
        :cx 0
        :cy 0
        :r 25)))))

(def elevation-exaggeration 4)

(defn elevation-path
  [params pass]
  (svg/g
   :attr {:class "approach-path"}
   (for [frame (-> pass :assessment ::grading/frames)]
     (let [{:keys [::grading/downrange
                   ::grading/height
                   ::grading/glideslope
                   ::acmi/t]} frame
           {:keys [::grading/value ::grading/deviation]} glideslope]
       [(svg/circle
         :attr {:glideslope value
                :t t
                :class (deviation-classes "glideslope-data" deviation)}
         :cx downrange
         :cy (* elevation-exaggeration height)
         :r 25)
        (if (neg? downrange)
          []
          (svg/g
           :transform (gstring/format "translate(%f %f)"
                                      downrange
                                      (+ (* 100 (-> frame ::grading/aoa ::grading/value (- 8.1)))
                                         (* elevation-exaggeration height)))
           (svg/circle
            :attr {:class (deviation-classes "aoa-deviation"
                                             (-> frame
                                                 ::grading/aoa
                                                 ::grading/deviation))}
            :cx 0
            :cy 0
            :r 10)))]))))

(let [angular-exaggeration 2
      x1 (units/deg->rad 4)
      x2 (units/deg->rad 10)]
  (defn exaggerate-angle
    "Make small angles bigxbger."
    ([rad]
     (cond
       (< (Math/abs rad) x1) (* angular-exaggeration rad)
       (< (Math/abs rad) x2) (-> rad
                                 Math/abs
                                 (- x1)
                                 (/ angular-exaggeration)
                                 (+ (* angular-exaggeration x1))
                                 (* (/ rad (Math/abs rad))))
       :else rad))
    ([x y]
     (let [r (Math/sqrt (+ (* x x) (* y y)))
           ax (Math/abs x)
           ay (Math/abs y)
           theta (Math/atan2 ay ax)
           theta' (exaggerate-angle theta)
           x' (* r (Math/cos theta'))
           y' (* r (Math/sin theta'))]
       ;; Sign of coordinates should match original signs
       [(* x' (/ x ax))
        (* y' (/ y ay))]))))

(defn plan-path
  [params pass]
  (svg/g
   :attr {:class "approach-path"}

   (for [frame (-> pass :assessment ::grading/frames)]
     (let [{:keys [::grading/downrange
                   ::grading/lineup
                   ::grading/crosstrack-error
                   ::grading/speed
                   ::acmi/t]} frame
           {:keys [::grading/value ::grading/deviation]} lineup
           [downrange* crosstrack*] (exaggerate-angle downrange crosstrack-error)]
       ;; TODO: Exaggerate the angle to make errors more obvious
       (svg/circle
        :attr {:lineup value
               :t t
               :speed speed
               :class (deviation-classes "lineup-data" deviation)}
        :cx (if (pos? downrange) downrange* downrange)
        :cy (if (pos? downrange) crosstrack* crosstrack-error)
        :r 25)))))

(defn range-lines
  "Draw the lines that show range, with their labels."
  [y1 y2 text-transform class]
  (for [x (range 0 (:east view-bounds) 1000)]
    [(svg/line
      :attr {:class (str class " range guideline")}
      :x1 x
      :y1 y1
      :x2 x
      :y2 y2)
     (svg/text
      :transform text-transform
      :attr {:class (str class " axis-label range")}
      :x (+ x 20)
      :y 0
      (str x))]))

(def elevation
  "Draws the side view of the pass."
  (formula-of
   [pass-parameters selected-pass]
   (let [{:keys [west east high low]} view-bounds
         [x y z] (:landing-point pass-parameters)]
     (svg/svg
      :attr {"xmlns" "http://www.w3.org/2000/svg"}
      :viewBox (gstring/format "%d %d %d %d"
                               west
                               (- high z)
                               (- east west)
                               (- high low))
      :id "elevation"
      (svg/g
       :transform (gstring/format "scale(1 -1) translate(0 %f)"
                                  (* -2 high))
       (svg/rect
        :attr {:class "sky"}
        :x west
        :y (- z)
        :width (- east west)
        :height (+ (* 2 z) high))
       (carrier-elevation z)
       (range-lines low
                    high
                    (gstring/format "scale(1 -1) translate(0 %f)"
                                    (- (+ low z)))
                    "elevation")
       ;; Colored glideslope guidelines
       (let [params (:glideslope pass-parameters)
             guideline (fn [angle class tx]
                         [(svg/line
                           :attr {:class (str "elevation guideline glideslope "
                                              class)}
                           :transform (gstring/format "translate(%f 0) rotate(%f)"
                                                      tx
                                                      (* angle elevation-exaggeration))
                           :x1 0
                           :y1 0
                           :x2 (* 2 east)
                           :y2 0)
                          (svg/text
                           :transform (gstring/format "translate(%f 0) rotate(%f) scale(1 -1)"
                                                      tx
                                                      (* angle elevation-exaggeration))
                           :attr {:class (str "axis-label elevation glideslope " class)}
                           :x (- east 500)
                           :y -20
                           (str angle "°"))])]
         (svg/g
          (guideline (:ideal params) "ideal" 0)
          (for [[k1 m] (select-keys params [:good :minor :major])
                [k2 v] (select-keys m [:low :high])
                :let [class (str (name k1) " " (name k2))
                      tx (-> pass-parameters
                             :landing-window
                             second
                             (/ 2))]]
            (guideline v class (if (= k2 :low)
                                 tx
                                 (- tx))))))
       ;; Guidelines for 3/4 mile, 450 feet
       (svg/line
        :attr {:class "elevation guideline three-quarter-mile"}
        :x1 west
        :y1 (* (- 450 z) elevation-exaggeration)
        :x2 east
        :y2 (* (- 450 z) elevation-exaggeration))
       (svg/text
        :transform "scale(1 -1)"
        :attr {:class "axis-label elevation height three-quarter-mile"}
        :x (+ west 20)
        :y (* (- z 460) elevation-exaggeration)
        "450")
       (svg/line
        :attr {:class "elevation range guideline three-quarter-mile"}
        :x1 (units/nm->ft 0.75)
        :y1 low
        :x2 (units/nm->ft 0.75)
        :y2 high)
       ;; A nil stops rendering. But an empty collection does not
       (if selected-pass
         (elevation-path (:glideslope pass-parameters) selected-pass)
         [])
       (svg/circle
        :attr {:class "landing-point-dot"}
        :cx 0
        :cy 0
        :r 20)
       )))))

(def plan
  "Draws the top view of the pass."
  (let [{:keys [west east north south]} view-bounds]
    (svg/svg
     :attr {"xmlns" "http://www.w3.org/2000/svg"}
     :id "plan"
     :viewBox (gstring/format "%d %d %d %d"
                              west
                              north
                              (- east west)
                              (- south north))
     (carrier-plan)
     (svg/line
      :attr {:class "plan angle zero guideline"}
      :x1 west
      :y1 0
      :x2 east
      :y2 0)
     (range-lines north
                  south
                  (gstring/format "translate(0 %f)" south)
                  "plan")
     (svg/line
      :attr {:class "plan range guideline three-quarter-mile"}
      :x1 (units/nm->ft 0.75)
      :y1 north
      :x2 (units/nm->ft 0.75)
      :y2 south)
     (formula-of
      [pass-parameters]
      (svg/g
       (let [params (:lineup pass-parameters)]
        (for [[k1 m] (select-keys params [:good :minor :major])
              [k2 v] (select-keys m [:low :high])]
          (let [angle (-> v units/deg->rad exaggerate-angle units/rad->deg)
                ty (-> pass-parameters
                       :landing-window
                       first
                       (/ 2)
                       (* (if (= k2 :low)
                            -1
                            1)))]
            [(svg/line
              :transform (gstring/format "translate(0 %f) rotate(%f)" ty angle)
              :attr {:class (str "plan angle guideline "
                                 (name k1) " " (name k2))}
              :x1 0
              :y1 0
              :x2 (* east 2)
              :y2 0)
             (svg/text
              :transform (gstring/format "translate(0 %f) rotate(%f)" ty angle)
              :attr {:class (str "axis-label plan angle "
                                 (name k1) " " (name k2))}
              :x (- east 500)
              :y -20
              (str (.toFixed v 1) "°"))])))))
     (svg/g
      ;; We need to invert the y axis because of the way the coordinate
      ;; systems interact: in landing space, crosstrack error increases
      ;; to the right
      :transform "scale(1 -1)"
      (formula-of
       [selected-pass pass-parameters]
       (when selected-pass
         (plan-path (:lineup pass-parameters) selected-pass)))
      (svg/circle
       :attr {:class "landing-point-dot"}
       :cx 0
       :cy 0
       :r 20)))))

(def titlebar
  (div :id "titlebar"
       (div :id "words"
            (span :id "title"
                  "LSOBot")
            (span :id "byline"
                  "by"
                  (a :href "http://firstfighterwing.com/VFW/member.php?893-Tyrant"
                     :target "_blank"
                     "Tyrant"))
            (span :id "helpstring"
                  "Help? Bug? Feature request? Click"
                  (a :href "help.html"
                     :target "_blank"
                     "here")
                  "."))
       (a :href "http://firstfighterwing.com"
          :target "_blank"
          (img :id "winglogo"
               :src "images/1stVFW_Insignia-64.png"))))

(def result-text
  {:trap "Trap"
   :waveoff "Waveoff"
   :ramp-strike "Ramp Strike"
   :bolter "Bolter"})

(def symbol-mapping
  {::grading/aoa-deviations        {:low  "F"
                                    :high "S"}
   ::grading/glideslope-deviations {:low  "LO"
                                    :high "H"}
   ::grading/lineup-deviations     {:low  "LUR"
                                    :high "LUL"}})

(defn assessment-mark
  [dimension deviation]
  (let [{:keys [::grading/degree ::grading/direction]} deviation]
    (if-not direction
      ""
      (let [mark (-> symbol-mapping dimension direction)]
        (if (#{:ideal :good} degree)
          ""
          mark)))))

(defn assessment-symbol
  [dimension deviation]
  (span
   :class ["assessment-symbol"
           (or (some-> deviation ::grading/degree name) "")
           (or (some-> deviation ::grading/direction name) "")]
   (assessment-mark dimension deviation)))

(defn not-implemented-cell
  [assessment]
  "-")

(defn grade-cell
  [assessment]
  (case (-> assessment ::grading/result)
    :bolter "B"
    :waveoff "WO"
    ""))

(def aw-cell not-implemented-cell)

(defn x-cell
  [assessment]
  (for [dimension [::grading/glideslope-deviations
                   ::grading/aoa-deviations
                   ;; TODO: Move lineup to lineup column
                   ;; ::grading/lineup-deviations
                   ]
        deviation (get-in assessment [::grading/start dimension])]
    (assessment-symbol dimension deviation)))

(def im-cell not-implemented-cell)
(def ic-cell not-implemented-cell)
(def ar-cell not-implemented-cell)
(def power-cell not-implemented-cell)
(def att-cell not-implemented-cell)
(def lineup-and-wing-cell not-implemented-cell)

(defn wire-cell
  [assessment]
  (case (-> assessment ::grading/result)
    :bolter "B"
    :waveoff "WO"
    ""))

(defn remarks-cell
  [assessment]
  (case (-> assessment ::grading/result)
    :trap "Trap"
    :ramp-strike "Ramp strike"
    ""))

(defn assessment
  "Returns UI for the assessment section"
  [passes selected-pass limit-displayed-passes?]
  (table
   :id "assessments"
   (thead
    (tr
     :class "header-1"
     (th
      :class "toggle-button"
      :colspan 4
      (let [limit-cell limit-displayed-passes?]
        (formula-of
         [passes selected-pass limit-displayed-passes?]
         (button
          :id "limit-pass-display"
          :toggle (and passes selected-pass (< 1 (count passes)))
          :click #(reset! limit-cell (not limit-displayed-passes?))
          (if limit-displayed-passes?
            "Show all passes"
            "Only show selected pass")))))
     (th :class "gs-speed-errors" :colspan 6 "Glideslope and Speed Errors")
     (th :class "control-errors" :colspan 2 "Control Errors")
     (th :class "lineup-and-wing" :rowspan 2 "Lineup & Wing")
     (th :class "wire" :rowspan 2 "Wire #")
     (th :class "remarks" :rowspan 2 "Remarks"))
    (tr
     :class "header-2"
     (th :class "select" "")
     (th :class "carrier"  "Carrier")
     (th :class "pilot"  "Pilot")
     (th :class "start" "Time")
     (th :class "grade" "Grade")
     (th :class "aw" "AW")
     (th :class "x" "X")
     (th :class "im" "IM")
     (th :class "ic" "IC")
     (th :class "ar" "AR")
     (th :class "power" "Power")
     (th :class "att" "ATT")))
   (tbody
    (let [selected-pass-cell selected-pass]
      (formula-of
       [passes selected-pass limit-displayed-passes?]
       (if (empty? passes)
         (tr (td :class "none-loaded" :colspan 15 "No Passes Detected"))
         (for [pass passes
               :let [{:keys [carrier-id pilot-id index assessment]} pass
                     frames (::grading/frames assessment)
                     td+ (fn [class cell-f]
                           (td :class (str class " assessment-cell")
                               (cell-f assessment)))]]
           (tr
            :css {:display (if (or (not selected-pass)
                                   (not limit-displayed-passes?)
                                   (= selected-pass pass))
                             "table-row"
                             "none")}
            (td+ "select"
                 (constantly
                  (input :type "radio"
                         :name "pass"
                         :click #(reset! selected-pass-cell pass)
                         :checked (= selected-pass pass))))
            (td+ "carrier"
                 (constantly
                  (-> frames
                      last
                      (acmi/entity carrier-id)
                      ::acmi/name)))
            (td+ "pilot"
                 (constantly
                  (-> frames
                      last
                      (acmi/entity pilot-id)
                      ::acmi/pilot)))
            (td+ "start"
                 (constantly
                  (->> pass :start (time-str nil))))
            (td+ "grade" grade-cell)
            (td+ "aw" aw-cell)
            (td+ "x" x-cell)
            (td+ "im" im-cell)
            (td+ "ic" ic-cell)
            (td+ "ar" ar-cell)
            (td+ "power" power-cell)
            (td+ "att" att-cell)
            (td+ "lineup-and-wing" lineup-and-wing-cell)
            (td+ "wire" wire-cell)
            (td+ "remarks" remarks-cell)))))))))

(def keymap {49 :one
             97 :a
             98 :b
             99 :c
             108 :l
             110 :n
             112 :p
             78 :N
             80 :P
             ;; TODO: The rest
             })

(defn scroll-to
  [id]
  (let [body (js/jQuery "body,html")
        elem (js/jQuery (gdom/getElement id))]
    (.animate body (clj->js {:scrollTop (.-top (.offset elem))}))))

(def key-action {:a #(scroll-to "aoa")
                 :b #(scroll-to "elevation")
                 :c #(scroll-to "plan")
                 :l #(load-acmi nil)
                 :n next-pass
                 :p prev-pass
                 :one #(swap! limit-displayed-passes? not)})

(defn keypress
  [e]
  (log/debug "Key pressed" :keycode (.-keyCode e))
  (when-let [action (some-> e .-keyCode keymap key-action)]
    (action)))

(html
 (head
  (title "LSOBot")
  (link :href "style.css" :rel "stylesheet" :title "main" :type "text/css")
  (link :href "https://fonts.googleapis.com/css?family=Open+Sans+Condensed:300"
        :rel "stylesheet"
        :type "text/css")
  (link :href "https://fonts.googleapis.com/css?family=Kalam"
        :rel "stylesheet"
        :type "text/css"))
 (body
  :id "body"
  ;;:keypress keypress
  titlebar
  (if-tpl loading?
    [(div
      :id "loading-placeholder"
      (span
       :id "loading-placeholder-message"
       "Loading...")
      (img :id "spinner" :src "images/spinner.gif"))]
    (button :id "load-button" :click load-acmi "Load ACMI"))
  (formula-of
   [acmi]
   (if-not acmi
     (div "No ACMI file loaded")
     []))
  (assessment passes selected-pass limit-displayed-passes?)
  (div
   :id "graphs"
   (div
    (div :class "graph-label" "Glideslope")
    elevation)
   (div
    (div :class "graph-label" "Lineup")
    plan))))

;; Keypresses handler was getting registered more than once when the
;; code would reload, which is super annoying.
(let [body (gdom/getElement "body")]
  (gevents/removeAll body EventType.KEYPRESS)
  (gevents/listen body EventType.KEYPRESS keypress))

(comment
  ;; This draw the table of passes. Might use it again
  (table
   :id "passes"
   (thead (tr (td) (td "Carrier") (td "Pilot") (td "Pass time")))
   (tbody
    (for-tpl [{:keys [carrier-id pilot-id start index]} passes]
      (do
        (log/debug :index index
                   :carrier-id carrier-id
                   :pilot-id pilot-id)
        (tr
         (td (input :type "radio"
                    :name "pass"
                    :click #(reset! selected-pass-index @index)
                    :checked (formula-of
                              [selected-pass-index]
                              (= selected-pass-index index))))
         (td (cell= (property carrier-id ::acmi/name)))
         (td (cell= (property pilot-id ::acmi/pilot)))
         (td (cell= (time-str reference-time start))))))))
  )
