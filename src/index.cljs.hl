(page "index.html"
  (:require [clojure.string :as str]
            [goog.dom :as gdom]
            [goog.events :as gevents]
            [goog.string :as gstring]
            [goog.string.format]
            [goog.style :as gstyle]
            [cljs.core.async :as async
             :refer [<! >! timeout]]
            [lsobot.acmi :as acmi]
            [lsobot.grading :as grading]
            [lsobot.units :as units]
            [hoplon.svg :as svg]
            [taoensso.timbre :as log
             :refer-macros (log trace debug info warn error fatal report
                                logf tracef debugf infof warnf errorf fatalf reportf
                                spy get-env log-env)])
  (:import [goog.events EventType])
  (:require-macros
   [cljs.core.async.macros :refer [go go-loop]]
   [lsobot.macros :refer [formula-of defformula]]))

;;; State

(defc pass-parameters grading/default-parameters)

(defc acmi nil)

(defc loading? false)

;; Looks like:
#_{:carrier-id "id-or-nil"
   :pilot-id "id-or-nil"
   :index "index-or-nil"}
(defc selected-pass-descriptor nil)

(defn get-passes
  [acmi params]
  (->>  (for [[carrier-id pilot-passes] (grading/passes acmi params)
              [pilot-id passes] pilot-passes
              pass-frames passes]
          {:frames     pass-frames
           :carrier-id carrier-id
           :start      (-> pass-frames first ::acmi/t)
           :pilot-id   pilot-id})
        (map-indexed (fn [index m]
                       (assoc m :index index)))))

(defformula passes
  [acmi pass-parameters]
  (get-passes acmi pass-parameters))

(defformula final-entities
  [acmi]
  (-> acmi
      ::acmi/frames
      last
      second
      ::acmi/entities))

(defformula selected-pass
  [selected-pass-descriptor passes]
  (let [{:keys [index]} selected-pass-descriptor]
    (when index
      (nth passes (long index)))))

(defn change-pass
  [index]
  (swap! selected-pass-descriptor
         assoc
         :index
         index))

(defn change-pilot
  [pilot-id]
  (let [indexes (->> @passes
                     (filter #(= (:carrier-id @selected-pass-descriptor)
                                 (:carrier-id %)))
                     (filter #(= pilot-id (:pilot-id %)))
                     (map :index))]
    (swap! selected-pass-descriptor
           assoc
           :pilot-id
           pilot-id
           :index
           nil)
    (when (= 1 (count indexes))
      (change-pass (first indexes)))))

(defn change-carrier
  [carrier-id]
  (let [pilot-ids (->> @passes
                       (filter #(= carrier-id (:carrier-id %)))
                       (map :pilot-id)
                       distinct)]
    (reset! selected-pass-descriptor
            {:carrier-id carrier-id})
    (when (= 1 (count pilot-ids))
      (change-pilot (first pilot-ids)))))

(defn update-pass
  "Change to a new pass, altering the current pass number by f."
  [f]
  (when-not (empty? @passes)
    (let [{:keys [index]} @selected-pass-descriptor
          next-index (f (or index -1))]
      (when (<= 0 next-index (dec (count @passes)))
        (let [next-pass (->> @passes
                             (filter #(= next-index (:index %)))
                             first)]
          (reset! selected-pass-descriptor
                  (select-keys next-pass [:carrier-id :pilot-id :index])))))))

(defn next-pass
  "Moves to the next pass in the list, if there is one."
  []
  (update-pass inc))

(defn prev-pass
  "Moves to the previous pass in the list, if ther eis one"
  []
  (update-pass dec))

;;; Utilities

(defn time-str
  [acmi t]
  ;; For now we're just going to assume the reference time is midnight
  (let [s (mod t 60)
        t (long (/ t 60))
        m (mod t 60)
        t (long (/ t 60))
        h (mod t 24)
        d (long (/ t 24))]
    (gstring/format "%02d/%02d:%02d:%02d" (inc d) h m s)))

(defn property
  [acmi id prop]
  (-> acmi ::acmi/frames last ::acmi/entities (get-in [id prop])))

;;; Serialization

(defn load-acmi
  [_]
  (let [i (gdom/createElement "input")
        ch (async/chan)]
    (-> i .-type (set! "file"))
    (-> (gdom/getDocument) .-body (gdom/appendChild i))
    (gstyle/showElement i false)
    (-> i .-onchange (set! (fn [e]
                             (async/put! ch e)
                             (async/close! ch))))
    (.click i)
    (go
      (let [e (<! ch)]
        (when-let [file (aget (.. e -target -files) 0)]
          (let [reader (js/FileReader.)]
            (-> reader
                .-onload
                (set! #(do
                         (reset! loading? true)
                         (go
                           ;; Give the loading changes to take
                           (<! (async/timeout 100))
                           (let [contents (-> % .-target .-result)]
                             (dosync
                              (reset! acmi (acmi/read-acmi contents))
                              (let [carrier-ids (->>  @passes
                                                      (map :carrier-id)
                                                      distinct)]
                                (when (= 1 (count carrier-ids))
                                  (change-carrier (first carrier-ids))))
                              (reset! loading? false)))))))
            (.readAsText reader file)))))))

;;; UI

(defmethod do! :viewBox
  [elem _ value]
  (if (= false value)
    (.removeAttribute elem "viewBox")
    (.setAttribute elem "viewBox" value)))

(defmethod do! :preserveAspectRatio
  [elem _ value]
  (if (= false value)
    (.removeAttribute elem "preserveAspectRatio")
    (.setAttribute elem "preserveAspectRatio" value)))

(def view-bounds
  {:west -1500
   :east 7000
   :north (units/nm->ft -0.25)
   :south (units/nm->ft 0.25)
   :high (units/nm->ft 0.5)
   :low -500
   :fast 5.5                            ; Degrees AOA
   :slow 10.5                           ; Degrees AOA
   ;;:aoa-aspect 6.7
   :aoa-aspect 4
   })

(defn carrier-elevation
  "SVG data for the elevation view of the carrier"
  [deck-height]
  (svg/g
   ;; TODO: Change this so that the zero point matches the location of
   ;; the landing point
   :transform (gstring/format "scale(-1 1) translate(970 -%f)" (double deck-height))
   (svg/path
    :id "carrier-outline-elevation"
    ;; The class attribute doesn't work correctly on SVG
    ;; elements, but we can use :attr to pull it off.
    :attr {:class "carrier-side"}
    :d (gstring/format "M-50 0 L0 %f L-1100 %f L-1100 0"
                       (double deck-height)
                       (double deck-height)))
   (svg/rect
    :attr {:class "carrier-side"}
    :x -850
    :y deck-height
    :width 150
    :height 90)
   (svg/rect
    :attr {:class "carrier-side"}
    :x -800
    :y 150
    :width 50
    :height deck-height)
   (svg/rect
    :attr {:class "carrier-side"}
    :x -850
    :y 150
    :width 25
    :height 40)))

(defn carrier-plan
  []
  "SVG data for the plan view of the carrier"
  (let [outline (svg/path
                 ;; The class attribute doesn't work correctly on SVG
                 ;; elements, but we can use :attr to pull it off.
                 :attr {:class "carrier-top"}
                 :d "M80 1100
L250 1100
L280 920
L280 350
L200 200
L180 0
L100 0
L80 200
L0 350
L0 920
L30 1100")]
    [(svg/defs
       ;; The carrier outline, relative to an origin at the port aft (is
       ;; this right?) corner, with X increasing to starboard, and Y
       ;; increasing forward
       (svg/clipPath
        :id "carrier-outline-clip"
        ;; Much as I would like to employ an SVG <use> element here,
        ;; rather than repeat myself from earlier, it doesn't render
        ;; right in Firefox or Safari
        (svg/path
         :d "M80 1100
L250 1100
L280 920
L280 350
L200 200
L180 0
L100 0
L80 200
L0 350
L0 920
L30 1100")))
     (svg/g
      :transform "rotate(-83) translate(-130 -970)"
      outline
      (svg/g
       :clip-path "url(#carrier-outline-clip)"
       (svg/g
        :transform (gstring/format "rotate(-7 180 1100)")
        (svg/line
         :attr {:class "carrier-top-markings end"}
         :x1 "180"
         :y1 "1090"
         :x2 "100"
         :y2 "1090")
        (svg/line
         :attr {:class "carrier-top-markings"}
         :x1 "180"
         :y1 "1100"
         :x2 "180"
         :y2 "0")
        (svg/line
         :attr {:class "carrier-top-markings"}
         :x1 "100"
         :y1 "1100"
         :x2 "100"
         :y2 "0")
        (svg/line
         :attr {:class "carrier-top-markings middle"}
         :x1 "140"
         :y1 "1100"
         :x2 "140"
         :y2 "0"))))]))

(def pitch-exaggeration 1)

(defn classify
  "Classifies the value according to params: ideal, good, minor,
  major, unacceptable."
  [params v]
  (let [{:keys [ideal good minor major]} params]
    (cond
      (= ideal v) :ideal
      (<= (:low good) v (:high good)) :good
      (<= (:low minor) v (:high minor)) :minor
      (<= (:low major) v (:high major)) :major
      :else :unacceptable)))

(def aoa-smoothing 0.9)

(defn aoa-path
  "Returns SVG data that shows the AOA data"
  [params scale pass]
  (log/debug "aoa-path"
             :map? (map? pass)
             :vector? (vector? pass)
             :first-map? (-> pass first map?))
  (svg/g
   :attr {:class "aoa-data"}
   (let [[frames _] (->> pass
                         :frames
                         (reduce (fn [acc frame]
                                   (let [[frames prior-aoa] acc
                                         aoa (::grading/aoa frame)
                                         prior-aoa (or prior-aoa aoa)
                                         ;; Sometimes there's no AOA
                                         ;; data for some reason
                                         aoa* (if-not aoa
                                                prior-aoa
                                                (+ (* aoa-smoothing prior-aoa)
                                                   (* (- 1 aoa-smoothing) aoa)))]
                                     [(conj frames (assoc frame
                                                          ::aoa aoa*
                                                          ::prior-aoa prior-aoa))
                                      aoa*]))
                                 [[] nil]))]
     (for [frame frames
           :let [{:keys [::aoa
                         ::prior-aoa
                         ::grading/downrange
                         ::grading/pilot]} frame]
           :when (and aoa (pos? downrange))]
       [(let [aoa (::grading/aoa data)]
          (svg/circle
           :attr {:class "original"}
           :transform (gstring/format "translate(%f %f) rotate(%f)"
                                      downrange
                                      (* scale aoa)
                                      (-> frame
                                          ::grading/pilot
                                          ::acmi/pitch
                                          (* -1 pitch-exaggeration)))
           :cx 0
           :cy 0
           :r 25))
        (svg/circle
         :attr {"smoothed-aoa" aoa
                "original-aoa" (::grading/aoa frame)
                "path-a" (::grading/path-a frame)
                "pitch"  (-> frame ::grading/pilot ::acmi/pitch)
                "prior-aoa" prior-aoa
                :class (str "smoothed " (name (classify params aoa)))}
         :transform (gstring/format "translate(%f %f) rotate(%f)"
                                    downrange
                                    (* scale aoa)
                                    (-> frame
                                        ::grading/pilot
                                        ::acmi/pitch
                                        (* -1 pitch-exaggeration)))
         :cx 0
         :cy 0
         :r 25)]
       ;; Lines instead of circles
       #_(svg/line
          :attr {"t" t
                 "aoa" aoa
                 "path-a" (::grading/path-a data)
                 "pitch"  (-> data ::grading/pilot ::acmi/pitch)
                 :class (name (classify params aoa))}
          :transform (gstring/format "translate(%f %f) rotate(%f)"
                                     downrange
                                     (* scale aoa)
                                     (-> data
                                         ::grading/pilot
                                         ::acmi/pitch
                                         (* -1 pitch-exaggeration)))
          :x1 -30
          :x2 30
          :y1 0
          :y2 0)))))

(def elevation-exaggeration 4)

(defn elevation-path
  [params pass]
  (svg/g
   :attr {:class "approach-path"}
   (for [frame (:frames pass)]
     (let [{:keys [::grading/downrange
                   ::grading/height
                   ::grading/glideslope]} frame]
       (svg/circle
        :attr {"glideslope" glideslope
               :class (if (pos? downrange)
                        (name (classify params glideslope))
                        "")}
        :cx downrange
        :cy (* elevation-exaggeration height)
        :r 25)))))

(let [angular-exaggeration 2
      x1 (units/deg->rad 4)
      x2 (units/deg->rad 10)]
  (defn exaggerate-angle
    "Make small angles bigxbger."
    ([rad]
     (cond
       (< (Math/abs rad) x1) (* angular-exaggeration rad)
       (< (Math/abs rad) x2) (-> rad
                                 Math/abs
                                 (- x1)
                                 (/ angular-exaggeration)
                                 (+ (* angular-exaggeration x1))
                                 (* (/ rad (Math/abs rad))))
       :else rad))
    ([x y]
     (let [r (Math/sqrt (+ (* x x) (* y y)))
           ax (Math/abs x)
           ay (Math/abs y)
           theta (Math/atan2 ay ax)
           theta' (exaggerate-angle theta)
           x' (* r (Math/cos theta'))
           y' (* r (Math/sin theta'))]
       ;; Sign of coordinates should match original signs
       [(* x' (/ x ax))
        (* y' (/ y ay))]))))

(defn plan-path
  [params pass]
  (svg/g
   :attr {:class "approach-path"}

   (for [frame (:frames pass)]
     (let [{:keys [::grading/downrange
                   ::grading/crosstrack-error
                   ::grading/course-deviation
                   ::grading/lineup]} frame
           [downrange* crosstrack*] (exaggerate-angle downrange crosstrack-error)]
       ;; TODO: Exaggerate the angle to make errors more obvious
       (svg/circle
        :attr {"lineup" lineup
               "course-dev" course-deviation
               :class (if (pos? downrange)
                        (name (classify params lineup))
                        "")}
        :cx (if (pos? downrange) downrange* downrange)
        :cy (if (pos? downrange) crosstrack* crosstrack-error)
        :r 25)))))

(defn range-lines
  "Draw the lines that show range, with their labels."
  [y1 y2 text-transform class]
  (for [x (range 0 (:east view-bounds) 1000)]
    [(svg/line
      :attr {:class (str class " range guideline")}
      :x1 x
      :y1 y1
      :x2 x
      :y2 y2)
     (svg/text
      :transform text-transform
      :attr {:class (str class " axis-label range")}
      :x (+ x 20)
      :y 0
      (str x))]))

(def aoa
  (formula-of
   [selected-pass pass-parameters]
   (let [{:keys [west east fast slow aoa-aspect]} view-bounds
         scale (/ (- east west) (- slow fast) aoa-aspect)]
     (svg/svg
      :attr {"xmlns" "http://www.w3.org/2000/svg"}
      ;;:preserveAspectRatio "none"
      :viewBox (gstring/format "%f %f %f %f"
                               west
                               (* slow scale)
                               (- east west)
                               (* (- slow fast) scale))
      :id "aoa"
      (svg/g
       :transform (gstring/format "scale(1 -1) translate(0 %f)"
                                  (* -2 slow scale))
       (range-lines (* slow scale)
                    (* fast scale)
                    (gstring/format "scale(1 -1) translate(0 %f)"
                                    (* -1 scale (+ fast 0.1)))
                    "aoa")
       (let [params (:aoa pass-parameters)
             guideline (fn [v class]
                         [(svg/line
                           :attr {:class (str "aoa guideline aoa-value " class)}
                           :x1 west
                           :y1 (* scale v)
                           :x2 east
                           :y2 (* scale v))
                          (svg/text
                           :transform (gstring/format "scale(1 -1) translate(0 %f)"
                                                      (* -1 scale (+ v 0.05)))
                           :attr {:class (str "aoa axis-label aoa-value " class)}
                           :x (+ west 50)
                           :y 0
                           (str v "°"))])]
         (svg/g
          (guideline (:ideal params) "ideal")
          (for [y [6 10]]
            (guideline y ""))
          (for [[k1 m] (select-keys params [:good :minor :major])
                [k2 v] (select-keys m [:low :high])
                :let [class (str (name k1) " " (name k2))] ]
            (guideline v class))))
       (if-not selected-pass
         []
         (aoa-path (:aoa pass-parameters) scale selected-pass)))))))

(def elevation
  "Draws the side view of the pass."
  (formula-of
   [pass-parameters selected-pass]
   (let [{:keys [west east high low]} view-bounds
         [x y z] (:landing-point pass-parameters)]
     (svg/svg
      :attr {"xmlns" "http://www.w3.org/2000/svg"}
      :viewBox (gstring/format "%d %d %d %d"
                               west
                               (- high z)
                               (- east west)
                               (- high low))
      :id "elevation"
      (svg/g
       :transform (gstring/format "scale(1 -1) translate(0 %f)"
                                  (* -2 high))
       (svg/rect
        :attr {:class "sky"}
        :x west
        :y (- z)
        :width (- east west)
        :height (+ (* 2 z) high))
       (carrier-elevation z)
       (range-lines low
                    high
                    (gstring/format "scale(1 -1) translate(0 %f)"
                                    (- (+ low z)))
                    "elevation")
       ;; Colored glideslope guidelines
       (let [params (:glideslope pass-parameters)
             guideline (fn [angle class tx]
                         [(svg/line
                           :attr {:class (str "elevation guideline glideslope "
                                              class)}
                           :transform (gstring/format "translate(%f 0) rotate(%f)"
                                                      tx
                                                      (* angle elevation-exaggeration))
                           :x1 0
                           :y1 0
                           :x2 (* 2 east)
                           :y2 0)
                          (svg/text
                           :transform (gstring/format "translate(%f 0) rotate(%f) scale(1 -1)"
                                                      tx
                                                      (* angle elevation-exaggeration))
                           :attr {:class (str "axis-label elevation glideslope " class)}
                           :x (- east 500)
                           :y -20
                           (str angle "°"))])]
         (svg/g
          (guideline (:ideal params) "ideal" 0)
          (for [[k1 m] (select-keys params [:good :minor :major])
                [k2 v] (select-keys m [:low :high])
                :let [class (str (name k1) " " (name k2))
                      tx (-> pass-parameters
                             :landing-window
                             second
                             (/ 2))]]
            (guideline v class (if (= k2 :low)
                                 tx
                                 (- tx))))))
       ;; Guidelines for 3/4 mile, 450 feet
       (svg/line
        :attr {:class "elevation guideline three-quarter-mile"}
        :x1 west
        :y1 (* (- 450 z) elevation-exaggeration)
        :x2 east
        :y2 (* (- 450 z) elevation-exaggeration))
       (svg/text
        :transform "scale(1 -1)"
        :attr {:class "axis-label elevation height three-quarter-mile"}
        :x (+ west 20)
        :y (* (- z 460) elevation-exaggeration)
        "450")
       (svg/line
        :attr {:class "elevation range guideline three-quarter-mile"}
        :x1 (units/nm->ft 0.75)
        :y1 low
        :x2 (units/nm->ft 0.75)
        :y2 high)
       ;; A nil stops rendering. But an empty collection does not
       (if selected-pass
         (elevation-path (:glideslope pass-parameters) selected-pass)
         [])
       (svg/circle
        :attr {:class "landing-point-dot"}
        :cx 0
        :cy 0
        :r 20)
       )))))

(def plan
  "Draws the top view of the pass."
  (let [{:keys [west east north south]} view-bounds]
    (svg/svg
     :attr {"xmlns" "http://www.w3.org/2000/svg"}
     :id "plan"
     :viewBox (gstring/format "%d %d %d %d"
                              west
                              north
                              (- east west)
                              (- south north))
     (carrier-plan)
     (svg/line
      :attr {:class "plan angle zero guideline"}
      :x1 west
      :y1 0
      :x2 east
      :y2 0)
     (range-lines north
                  south
                  (gstring/format "translate(0 %f)" south)
                  "plan")
     (svg/line
      :attr {:class "plan range guideline three-quarter-mile"}
      :x1 (units/nm->ft 0.75)
      :y1 north
      :x2 (units/nm->ft 0.75)
      :y2 south)
     (formula-of
      [pass-parameters]
      (svg/g
       (let [params (:lineup pass-parameters)]
        (for [[k1 m] (select-keys params [:good :minor :major])
              [k2 v] (select-keys m [:low :high])]
          (let [angle (-> v units/deg->rad exaggerate-angle units/rad->deg)
                ty (-> pass-parameters
                       :landing-window
                       first
                       (/ 2)
                       (* (if (= k2 :low)
                            -1
                            1)))]
            [(svg/line
              :transform (gstring/format "translate(0 %f) rotate(%f)" ty angle)
              :attr {:class (str "plan angle guideline "
                                 (name k1) " " (name k2))}
              :x1 0
              :y1 0
              :x2 (* east 2)
              :y2 0)
             (svg/text
              :transform (gstring/format "translate(0 %f) rotate(%f)" ty angle)
              :attr {:class (str "axis-label plan angle "
                                 (name k1) " " (name k2))}
              :x (- east 500)
              :y -20
              (str (.toFixed v 1) "°"))])))))
     (svg/g
      ;; We need to invert the y axis because of the way the coordinate
      ;; systems interact: in landing space, crosstrack error increases
      ;; to the right
      :transform "scale(1 -1)"
      (formula-of
       [selected-pass pass-parameters]
       (when selected-pass
         (plan-path (:lineup pass-parameters) selected-pass)))
      (svg/circle
       :attr {:class "landing-point-dot"}
       :cx 0
       :cy 0
       :r 20)))))

(def carrier-select-ui
  [(label :for "carrier-select" "Carrier:")
   (formula-of
    [acmi passes selected-pass-descriptor]
    (select
     :id "carrier-select"
     :change #(change-carrier @%)
     (let [{:keys [carrier-id]} selected-pass-descriptor
           carrier-ids (->> passes
                            (map :carrier-id)
                            distinct)]
       (into (if carrier-id
               []
               [(option
                 :selected true
                 :value ""
                 "Select a carrier")])
             (for [[cid name] (->> (for [id carrier-ids]
                                     [id (property acmi id "Name")])
                                   (sort-by second))]
               (option
                :selected (= cid carrier-id)
                :value cid
                name))))))])

(def pilot-select-ui
  [(label :for "pilot-select" "Pilot:")
   (formula-of
    [acmi passes selected-pass-descriptor]
    (select
     :id "pilot-select"
     :change #(change-pilot @%)
     (let [{:keys [carrier-id pilot-id]} selected-pass-descriptor
           pilot-ids (->> passes
                          (filter #(= carrier-id
                                      (:carrier-id %)))
                          (map :pilot-id)
                          distinct)]
       (into (if pilot-id
               []
               [(option
                 :selected true
                 :value ""
                 "Select a pilot")])
             (for [[pid name] (->> (for [id pilot-ids]
                                     [id (property acmi id ::acmi/pilot)])
                                   (sort-by second))]
               (option
                :selected (= pid pilot-id)
                :value pid
                name))))))])

(def pass-select-ui
  [(label :for "pass-select" "Pass starting at:")
   (formula-of
    [acmi passes selected-pass-descriptor]
    (select
     :id "pass-select"
     :change #(change-pass (js/Number. @%))
     (let [{:keys [carrier-id pilot-id index]} selected-pass-descriptor
           passes* (->> passes
                        (filter #(= carrier-id (:carrier-id %)))
                        (filter #(= pilot-id (:pilot-id %)))
                        (sort-by :index))]
       (into (if (and index pilot-id)
               []
               [(option
                 :selected true
                 :value ""
                 "Select a pass")])
             (for [pass passes*]
               (option
                :selected (and index (= (long (:index pass)) (long index)))
                :value (-> pass :index str)
                (time-str acmi (:start pass))))))))])

(def pass-selection-ui
  (fieldset
   :id "pass-selection-section"
   (legend "Pass selection")
   carrier-select-ui
   pilot-select-ui
   pass-select-ui)

  ;; TODO: Move this to the bottom as a summary
  #_[(table
      :id "passes"
      (thead (tr (td) (td "Carrier") (td "Pilot") (td "Pass time")))
      (tbody
       (for-tpl [{:keys [carrier-id pilot-id start index]} passes]
         (do
           (log/debug :index index
                      :carrier-id carrier-id
                      :pilot-id pilot-id)
           (tr
            (td (input :type "radio"
                       :name "pass"
                       :click #(reset! selected-pass-index @index)
                       :checked (formula-of
                                 [selected-pass-index]
                                 (= selected-pass-index index))))
            (td (cell= (property carrier-id "Name")))
            (td (cell= (property pilot-id ::acmi/pilot)))
            (td (cell= (time-str reference-time start))))))))])

(def titlebar
  (div :id "titlebar"
       (div :id "words"
            (span :id "title"
                  "LSOBot")
            (span :id "byline"
                  "by"
                  (a :href "http://firstfighterwing.com/VFW/member.php?893-Tyrant"
                     :target "_blank"
                     "Tyrant"))
            (span :id "helpstring"
                  "Help? Bug? Feature request? Click"
                  (a :href "help.html"
                     :target "_blank"
                     "here")
                  "."))
       (a :href "http://firstfighterwing.com"
          :target "_blank"
          (img :id "winglogo"
               :src "images/1stVFW_Insignia-64.png"))))

(def keymap {97 :a
             98 :b
             99 :c
             108 :l
             110 :n
             112 :p
             78 :N
             80 :P
             ;; TODO: The rest
             })

(defn scroll-to
  [id]
  (let [body (js/jQuery "body,html")
        elem (js/jQuery (gdom/getElement id))]
    (.animate body (clj->js {:scrollTop (.-top (.offset elem))}))))

(def key-action {:a #(scroll-to "aoa")
                 :b #(scroll-to "elevation")
                 :c #(scroll-to "plan")
                 :l #(load-acmi nil)
                 :n next-pass
                 :p prev-pass})

(defn keypress
  [e]
  (log/debug "Key pressed" :keycode (.-keyCode e))
  (when-let [action (some-> e .-keyCode keymap key-action)]
    (action)))

(html
 (head
  (title "LSOBot")
  (link :href "style.css" :rel "stylesheet" :title "main" :type "text/css")
  (link :href "https://fonts.googleapis.com/css?family=Open+Sans+Condensed:300"
        :rel "stylesheet"
        :type "text/css"))
 (body
  :id "body"
  ;;:keypress keypress
  titlebar
  (if-tpl loading?
    [(div
      :id "loading-placeholder"
      (span
       :id "loading-placeholder-message"
       "Loading...")
      (img :id "spinner" :src "images/spinner.gif"))]
    (button :click load-acmi "Load ACMI"))
  (formula-of
   [acmi passes]
   (cond
     (not acmi) (div "No ACMI file loaded")
     (empty? passes) (div "No passes detected in loaded ACMI")
     :else pass-selection-ui))
  (div
   :id "graphs"
   aoa
   elevation
   plan)))

;; Keypresses handler was getting registered more than once when the
;; code would reload, which is super annoying.
(let [body (gdom/getElement "body")]
  (gevents/removeAll body EventType.KEYPRESS)
  (gevents/listen body EventType.KEYPRESS keypress))

(comment
  ;; This draw the table of passes. Might use it again
  (table
   :id "passes"
   (thead (tr (td) (td "Carrier") (td "Pilot") (td "Pass time")))
   (tbody
    (for-tpl [{:keys [carrier-id pilot-id start index]} passes]
      (do
        (log/debug :index index
                   :carrier-id carrier-id
                   :pilot-id pilot-id)
        (tr
         (td (input :type "radio"
                    :name "pass"
                    :click #(reset! selected-pass-index @index)
                    :checked (formula-of
                              [selected-pass-index]
                              (= selected-pass-index index))))
         (td (cell= (property carrier-id "Name")))
         (td (cell= (property pilot-id ::acmi/pilot)))
         (td (cell= (time-str reference-time start))))))))
  )
