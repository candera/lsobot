(page "index.html"
  (:require [clojure.string :as str]
            [goog.dom :as gdom]
            [goog.string :as gstring]
            [goog.string.format]
            [goog.style :as gstyle]
            [cljs.core.async :as async
             :refer [<! >! timeout]]
            [lsobot.acmi :as acmi]
            [lsobot.grading :as grading]
            [lsobot.units :as units]
            [hoplon.svg :as svg]
            [taoensso.timbre :as log
             :refer-macros (log trace debug info warn error fatal report
                                logf tracef debugf infof warnf errorf fatalf reportf
                                spy get-env log-env)])
  (:require-macros
   [cljs.core.async.macros :refer [go go-loop]]
   [lsobot.macros :refer [formula-of defformula]]))

;;; State

(defc pass-parameters grading/default-parameters)

(defc acmi nil)

(defc loading? false)

;; Looks like:
#_{:carrier-id "id-or-nil"
   :pilot-id "id-or-nil"
   :index "index-or-nil"}
(defc selected-pass-descriptor nil)

(defn get-passes
  [acmi params]
  (->>  (for [[carrier-id pilot-passes] (grading/passes acmi params)
              [pilot-id passes] pilot-passes
              pass-frames passes]
          {:frames     pass-frames
           :carrier-id carrier-id
           :start      (-> pass-frames first first)
           :pilot-id   pilot-id})
        (map-indexed (fn [index m]
                       (assoc m :index index)))))

(defformula passes
  [acmi pass-parameters]
  (get-passes acmi pass-parameters))

(defformula final-entities
  [acmi]
  (-> acmi
      ::acmi/frames
      last
      second
      ::acmi/entities))

(defformula selected-pass
  [selected-pass-descriptor passes]
  (log/debug "selected-pass"
             :selected-pass-descriptor selected-pass-descriptor)
  (let [{:keys [index]} selected-pass-descriptor]
    (when index
      (nth passes (long index)))))

(defn change-pass
  [index]
  (log/debug "change-pass"
             :index index
             :index-type (type index))
  (swap! selected-pass-descriptor
         assoc
         :index
         index))

(defn change-pilot
  [pilot-id]
  (log/debug "change-pilot" :pilot-id pilot-id)
  (let [indexes (->> @passes
                     (filter #(= (:carrier-id @selected-pass-descriptor)
                                 (:carrier-id %)))
                     (filter #(= pilot-id (:pilot-id %)))
                     (map :index))]
    (swap! selected-pass-descriptor
           assoc
           :pilot-id
           pilot-id
           :index
           nil)
    (log/debug "change-pilot" :indexes indexes)
    (when (= 1 (count indexes))
      (change-pass (first indexes)))))

(defn change-carrier
  [carrier-id]
  (log/debug "change-carrier" :carrier-id carrier-id)
  (let [pilot-ids (->> @passes
                       (filter #(= carrier-id (:carrier-id %)))
                       (map :pilot-id)
                       distinct)]
    (reset! selected-pass-descriptor
            {:carrier-id carrier-id})
    (when (= 1 (count pilot-ids))
      (change-pilot (first pilot-ids)))))

(defn update-pass
  "Change to a new pass, altering the current pass number by f."
  [f]
  (when-not (empty? @passes)
    (let [{:keys [index]} @selected-pass-descriptor
          next-index (f (or index -1))]
      (when (<= 0 next-index (dec (count @passes)))
        (let [next-pass (->> @passes
                             (filter #(= next-index (:index %)))
                             first)]
          (reset! selected-pass-descriptor
                  (select-keys next-pass [:carrier-id :pilot-id :index])))))))

(defn next-pass
  "Moves to the next pass in the list, if there is one."
  []
  (update-pass inc))

(defn prev-pass
  "Moves to the previous pass in the list, if ther eis one"
  []
  (update-pass dec))

;;; Utilities

(defn time-str
  [acmi t]
  ;; For now we're just going to assume the reference time is midnight
  (let [s (mod t 60)
        t (long (/ t 60))
        m (mod t 60)
        t (long (/ t 60))
        h (mod t 24)
        d (long (/ t 24))]
    (gstring/format "%02d/%02d:%02d:%02d" (inc d) h m s)))

(defn property
  [acmi id prop]
  (-> acmi ::acmi/frames last second ::acmi/entities (get-in [id prop])))

#_(defn line-seq
  "Return a lazy sequence of lines from file."
  [file]
  (let [chunks (async/chan)
        lines (async/chan)
        reader (js/FileReader.)
        chunk-size 1024]
    (-> reader
        .-onload
        (set! #(go (->> % .-target .-result (>! chunks)))))
    ;; Read chunks from file
    (go-loop [offset 0]
      ;; TODO
      )
    ;; Split chunks into lines
    (go-loop [leftover ""]
      (when-let [chunk (<! chunks)]
        (let [parse (str/split-lines (str leftover chunk))
              [complete partial] (if (.endsWith chunk "\n")
                                   [parts ""]
                                   [(butlast parts) (last parts)])]
          (doseq [line complete]
            (>! lines line))
          (recur partial))))
    ;; TODO: Convert to lazy sequence. How do do that in
    ;; Clojurescript? Is it even possible? Maybe we just go with
    ;; channels, since they're universal.
    ))

;;; Serialization

(defn load-acmi
  [_]
  (let [i (gdom/createElement "input")
        ch (async/chan)]
    (-> i .-type (set! "file"))
    (-> (gdom/getDocument) .-body (gdom/appendChild i))
    (gstyle/showElement i false)
    (-> i .-onchange (set! (fn [e]
                             (async/put! ch e)
                             (async/close! ch))))
    (.click i)
    (go
      (let [e (<! ch)]
        (when-let [file (aget (.. e -target -files) 0)]
          (let [reader (js/FileReader.)]
            (-> reader
                .-onload
                (set! #(do
                         (reset! loading? true)
                         (go
                           ;; Give the loading changes to take
                           (<! (async/timeout 100))
                           (let [contents (-> % .-target .-result)]
                             (reset! acmi (acmi/read-acmi contents))
                             (let [carrier-ids (log/spy (->>  @passes
                                                              (map :carrier-id)
                                                              distinct))]
                               (when (= 1 (count carrier-ids))
                                 (change-carrier (first carrier-ids))))
                             (reset! loading? false))))))
            (.readAsText reader file)))))))


;;; UI

(defmethod do! :viewBox
  [elem _ value]
  (log/debug "viewBox" :value value)
  (if (= false value)
    (.removeAttribute elem "viewBox")
    (.setAttribute elem "viewBox" value)))

(defmethod do! :preserveAspectRatio
  [elem _ value]
  (log/debug "preserveAspectRatio" :value value)
  (if (= false value)
    (.removeAttribute elem "preserveAspectRatio")
    (.setAttribute elem "preserveAspectRatio" value)))

(def view-bounds
  {:west -1500
   :east (units/nm->ft 1.45)
   :north (units/nm->ft -0.4)
   :south (units/nm->ft 0.4)
   :high (units/nm->ft 0.6)
   :low -500
   :fast 3                              ; Degrees AOA
   :slow 10                             ; Degrees AOA
   :aoa-aspect 6.7
   })

(defn carrier-elevation
  "SVG data for the elevation view of the carrier"
  [deck-height]
  (svg/g
   ;; TODO: Change this so that the zero point matches the location of
   ;; the landing point
   :transform (gstring/format "scale(-1 1) translate(970 -%f)" (double deck-height))
   (svg/path
    :id "carrier-outline-elevation"
    ;; The class attribute doesn't work correctly on SVG
    ;; elements, but we can use :attr to pull it off.
    :attr {:class "carrier-side"}
    :d (gstring/format "M-50 0 L0 %f L-1100 %f L-1100 0"
                       (double deck-height)
                       (double deck-height)))
   (svg/rect
    :attr {:class "carrier-side"}
    :x -850
    :y deck-height
    :width 150
    :height 90)
   (svg/rect
    :attr {:class "carrier-side"}
    :x -800
    :y 150
    :width 50
    :height deck-height)
   (svg/rect
    :attr {:class "carrier-side"}
    :x -850
    :y 150
    :width 25
    :height 40)))

(defn carrier-plan
  []
  "SVG data for the plan view of the carrier"
  (let [outline (svg/path
                 ;; The class attribute doesn't work correctly on SVG
                 ;; elements, but we can use :attr to pull it off.
                 :attr {:class "carrier-top"}
                 :d "M80 1100
L250 1100
L280 920
L280 350
L200 200
L180 0
L100 0
L80 200
L0 350
L0 920
L30 1100")]
    [(svg/defs
       ;; The carrier outline, relative to an origin at the port aft (is
       ;; this right?) corner, with X increasing to starboard, and Y
       ;; increasing forward
       (svg/clipPath
        :id "carrier-outline-clip"
        ;; Much as I would like to employ an SVG <use> element here,
        ;; rather than repeat myself from earlier, it doesn't render
        ;; right in Firefox or Safari
        (svg/path
         :d "M80 1100
L250 1100
L280 920
L280 350
L200 200
L180 0
L100 0
L80 200
L0 350
L0 920
L30 1100")))
     (svg/g
      :transform "rotate(-83) translate(-130 -970)"
      outline
      (svg/g
       :clip-path "url(#carrier-outline-clip)"
       (svg/g
        :transform (gstring/format "rotate(-7 180 1100)")
        (svg/line
         :attr {:class "carrier-top-markings end"}
         :x1 "180"
         :y1 "1090"
         :x2 "100"
         :y2 "1090")
        (svg/line
         :attr {:class "carrier-top-markings"}
         :x1 "180"
         :y1 "1100"
         :x2 "180"
         :y2 "0")
        (svg/line
         :attr {:class "carrier-top-markings"}
         :x1 "100"
         :y1 "1100"
         :x2 "100"
         :y2 "0")
        (svg/line
         :attr {:class "carrier-top-markings middle"}
         :x1 "140"
         :y1 "1100"
         :x2 "140"
         :y2 "0"))))]))

(def pitch-exaggeration 1)

(defn aoa-path
  "Returns SVG data that shows the AOA data"
  [scale pass]
  (let [{:keys [frames]} pass]
    (svg/g
     :attr {:class "aoa-data"}
     (for [[t data] frames
           :let [{:keys [::grading/aoa
                         ::grading/downrange
                         ::grading/pilot]} data]
           :when (and aoa (pos? downrange))]
       (svg/line
        :attr {"t" t
               "aoa" aoa
               "path-a" (::grading/path-a data)
               "pitch"  (-> data ::grading/pilot ::acmi/pitch)}
        :transform (gstring/format "translate(%f %f) rotate(%f)"
                                   downrange
                                   (* scale aoa)
                                   (-> data
                                       ::grading/pilot
                                       ::acmi/pitch
                                       (* -1 pitch-exaggeration)))
        :x1 -30
        :x2 30
        :y1 0
        :y2 0)))))

(def elevation-exaggeration 4)

(defn elevation-path
  [pass]
  (let [{:keys [frames]} pass]
    (svg/g
     :attr {:class "approach-path"}
     (for [[t data] frames]
       (let [{:keys [::grading/downrange
                     ::grading/height]} data]
         (svg/circle
          :cx downrange
          :cy (* elevation-exaggeration height)
          :r 25))))))

(let [angular-exaggeration 2
      x1 (units/deg->rad 2)
      x2 (units/deg->rad 10)]
 (defn exaggerate-angle
   "Make small angles bigxbger."
   ([rad]
    (cond
      (< (Math/abs rad) x1) (* angular-exaggeration rad)
      (< (Math/abs rad) x2) (-> rad
                                Math/abs
                                (- x1)
                                (/ angular-exaggeration)
                                (+ (* angular-exaggeration x1))
                                (* (/ rad (Math/abs rad))))
      :else rad))
   ([x y]
    (let [r (Math/sqrt (+ (* x x) (* y y)))
          ax (Math/abs x)
          ay (Math/abs y)
          theta (Math/atan2 ay ax)
          theta' (exaggerate-angle theta)
          x' (* r (Math/cos theta'))
          y' (* r (Math/sin theta'))]
      ;; Sign of coordinates should match original signs
      [(* x' (/ x ax))
       (* y' (/ y ay))]))))

(defn plan-path
  [pass]
  (let [{:keys [frames]} pass]
    (svg/g
     :attr {:class "approach-path"}

     (for [[t data] frames]
       (let [{:keys [::grading/downrange
                     ::grading/crosstrack-error]} data
             [downrange* crosstrack*] (exaggerate-angle downrange crosstrack-error)]
         ;; TODO: Exaggerate the angle to make errors more obvious
         (svg/circle
          :cx (if (pos? downrange) downrange* downrange)
          :cy (if (pos? downrange) crosstrack* crosstrack-error)
          :r 25))))))

(defn range-lines
  "Draw the lines that show range, with their labels."
  [y1 y2 text-transform class]
  (for [x (range 0 (:east view-bounds) 1000)]
    [(svg/line
      :attr {:class (str class " range guideline")}
      :x1 x
      :y1 y1
      :x2 x
      :y2 y2)
     (svg/text
      :transform text-transform
      :attr {:class (str class " axis-label range")}
      :x x
      :y 0
      (str x))]))

(def aoa
  (formula-of
   [selected-pass]
   (let [{:keys [west east fast slow aoa-aspect]} view-bounds
         scale (/ (- east west) (- slow fast) aoa-aspect)]
     (log/debug "aoa" :scale scale)
     (svg/svg
      :attr {"xmlns" "http://www.w3.org/2000/svg"}
      ;;:preserveAspectRatio "none"
      :viewBox (gstring/format "%f %f %f %f"
                               west
                               (* slow scale)
                               (- east west)
                               (* (- slow fast) scale))
      :id "aoa"
      (svg/g
       :transform (gstring/format "scale(1 -1) translate(0 %f)"
                                  (* -2 slow scale))
       (range-lines (* slow scale)
                    (* fast scale)
                    (gstring/format "scale(1 -1) translate(0 %f)"
                                    (* -1 scale (+ fast 0.1))
                                    #_(* (- aspect-ratio) (- slow fast)))
                    "aoa")
       (for [y (range (+ fast 1) slow 1)]
         [(svg/line
            :attr {:class "aoa guideline aoa-value"}
            :x1 west
            :y1 (* scale y)
            :x2 east
            :y2 (* scale y))
          (svg/text
           :transform (gstring/format "scale(1 -1) translate(0 %f)"
                                      (* -1 scale (+ y 0.05))
                                      #_(* (- aspect-ratio) (- slow fast)))
           :attr {:class "aoa axis-label aoa-value"}
           :x (+ west 50)
           :y 0
           (str y "°"))])
       (if-not selected-pass
         []
         (aoa-path scale selected-pass)))))))

(def elevation
  "Draws the side view of the pass."
  (formula-of
   [pass-parameters selected-pass]
   (let [{:keys [west east high low]} view-bounds
         [x y z] (:landing-point pass-parameters)]
     (svg/svg
      :attr {"xmlns" "http://www.w3.org/2000/svg"}
      :viewBox (gstring/format "%d %d %d %d"
                               west
                               (- high z)
                               (- east west)
                               (- high low))
      :id "elevation"
      (svg/g
       :transform (gstring/format "scale(1 -1) translate(0 %f)"
                                  (* -2 high))
       (svg/rect
        :attr {:class "sky"}
        :x west
        :y (- z)
        :width (- east west)
        :height (+ (* 2 z) high))
       (carrier-elevation z)
       (range-lines low
                    high
                    (gstring/format "scale(1 -1) translate(0 %f)"
                                    (- (+ low z)))
                    "elevation")
       (for [angle (range 2.5 5 0.5)]
         [(svg/line
           :transform (gstring/format "rotate(%f)" (* angle elevation-exaggeration))
           :attr {:class "elevation glideslope guideline"}
           :x1 0
           :y1 0
           :x2 (* 2 east)
           :y2 0)
          (svg/text
           :transform (gstring/format "rotate(%f) scale(1 -1)" (* angle elevation-exaggeration))
           :attr {:class "axis-label elevation glideslope"}
           :x 8500
           :y -20
           (str angle "°"))])
       ;; Guidelines for 3/4 mile, 450 feet
       (svg/line
        :attr {:class "elevation guideline three-quarter-mile"}
        :x1 west
        :y1 (* (- 450 z) elevation-exaggeration)
        :x2 east
        :y2 (* (- 450 z) elevation-exaggeration))
       (svg/text
        :transform "scale(1 -1)"
        :attr {:class "axis-label elevation height three-quarter-mile"}
        :x (+ west 20)
        :y (* (- z 460) elevation-exaggeration)
        "450")
       (svg/line
        :attr {:class "elevation range guideline three-quarter-mile"}
        :x1 (units/nm->ft 0.75)
        :y1 low
        :x2 (units/nm->ft 0.75)
        :y2 high)
       ;; A nil stops rendering. But an empty collection does not
       (if selected-pass
         (elevation-path selected-pass)
         [])
       (svg/circle
        :attr {:class "landing-point-dot"}
        :cx 0
        :cy 0
        :r 20)
       )))))

(def plan
  "Draws the top view of the pass."
  (let [{:keys [west east north south]} view-bounds]
    (svg/svg
     :attr {"xmlns" "http://www.w3.org/2000/svg"}
     :id "plan"
     :viewBox (gstring/format "%d %d %d %d"
                              west
                              north
                              (- east west)
                              (- south north))
     (carrier-plan)
     (svg/line
      :attr {:class "plan angle zero guideline"}
      :x1 west
      :y1 0
      :x2 east
      :y2 0)
     (range-lines north
                  south
                  (gstring/format "translate(0 %f)" south)
                  "plan")
     (svg/line
      :attr {:class "plan range guideline three-quarter-mile"}
      :x1 (units/nm->ft 0.75)
      :y1 north
      :x2 (units/nm->ft 0.75)
      :y2 south)
     (for [x (range -2 2.1 1)]
       (let [xr (units/deg->rad x)
             angle (units/rad->deg (exaggerate-angle xr))]
         [(svg/line
           :transform (gstring/format "rotate(%f)" angle)
           :attr {:class "plan angle guideline"}
           :x1 0
           :y1 0
           :x2 (* east 2)
           :y2 0)]))
     (for [x [-2 -1 0 1 2]]
       (let [xr (units/deg->rad x)
             angle (units/rad->deg (exaggerate-angle xr))]
         (svg/text
          :transform (gstring/format "rotate(%f)" angle)
          :attr {:class "axis-label plan angle"}
          :x 8000
          :y -20
          (str (.toFixed x 1) "°"))))
     (svg/g
      ;; We need to invert the y axis because of the way the coordinate
      ;; systems interact: in landing space, crosstrack error increases
      ;; to the right
      :transform "scale(1 -1)"
      (formula-of
       [selected-pass]
       (when selected-pass
         (plan-path selected-pass)))
      (svg/circle
       :attr {:class "landing-point-dot"}
       :cx 0
       :cy 0
       :r 20)))))

(def carrier-select-ui
  [(label :for "carrier-select" "Carrier:")
   (formula-of
    [acmi passes selected-pass-descriptor]
    (select
     :id "carrier-select"
     :change #(change-carrier @%)
     (let [{:keys [carrier-id]} selected-pass-descriptor
           carrier-ids (->> passes
                            (map :carrier-id)
                            distinct)]
       (into (if carrier-id
               []
               [(option
                 :selected true
                 :value ""
                 "Select a carrier")])
             (for [[cid name] (->> (for [id carrier-ids]
                                     [id (property acmi id "Name")])
                                   (sort-by second))]
               (option
                :selected (= cid carrier-id)
                :value cid
                name))))))])

(def pilot-select-ui
  [(label :for "pilot-select" "Pilot:")
   (formula-of
    [acmi passes selected-pass-descriptor]
    (select
     :id "pilot-select"
     :change #(change-pilot @%)
     (let [{:keys [carrier-id pilot-id]} selected-pass-descriptor
           pilot-ids (->> passes
                          (filter #(= carrier-id
                                      (:carrier-id %)))
                          (map :pilot-id)
                          distinct)]
       (into (if pilot-id
               []
               [(option
                 :selected true
                 :value ""
                 "Select a pilot")])
             (for [[pid name] (->> (for [id pilot-ids]
                                     [id (property acmi id ::acmi/pilot)])
                                   (sort-by second))]
               (option
                :selected (= pid pilot-id)
                :value pid
                name))))))])

(def pass-select-ui
  [(label :for "pass-select" "Pass starting at:")
   (formula-of
    [acmi passes selected-pass-descriptor]
    (log/debug "pass-select-ui"
               :selected-pass-descriptor selected-pass-descriptor
               ;;:passes passes
               )
    (select
     :id "pass-select"
     :change #(change-pass (js/Number. @%))
     (let [{:keys [carrier-id pilot-id index]} selected-pass-descriptor
           passes* (->> passes
                        (filter #(= carrier-id (:carrier-id %)))
                        (filter #(= pilot-id (:pilot-id %)))
                        (sort-by :index))]
       (into (if (and index pilot-id)
               []
               [(option
                 :selected true
                 :value ""
                 "Select a pass")])
             (for [pass passes*]
               (option
                :selected (and index (= (long (:index pass)) (long index)))
                :value (-> pass :index str)
                (time-str acmi (:start pass))))))))])

(def pass-selection-ui
  (fieldset
   :id "pass-selection-section"
   (legend "Pass selection")
   carrier-select-ui
   pilot-select-ui
   pass-select-ui)

  ;; TODO: Move this to the bottom as a summary
  #_[(table
      :id "passes"
      (thead (tr (td) (td "Carrier") (td "Pilot") (td "Pass time")))
      (tbody
       (for-tpl [{:keys [carrier-id pilot-id start index]} passes]
         (do
           (log/debug :index index
                      :carrier-id carrier-id
                      :pilot-id pilot-id)
           (tr
            (td (input :type "radio"
                       :name "pass"
                       :click #(reset! selected-pass-index @index)
                       :checked (formula-of
                                 [selected-pass-index]
                                 (= selected-pass-index index))))
            (td (cell= (property carrier-id "Name")))
            (td (cell= (property pilot-id ::acmi/pilot)))
            (td (cell= (time-str reference-time start))))))))])

(def titlebar
  (div :id "titlebar"
       (div :id "words"
            (span :id "title"
                  "LSOBot")
            (span :id "byline"
                  "by"
                  (a :href "http://firstfighterwing.com/VFW/member.php?893-Tyrant"
                     :target "_blank"
                     "Tyrant"))
            (span :id "helpstring"
                  "Help? Bug? Feature request? Click"
                  (a :href "help.html"
                     :target "_blank"
                     "here")
                  "."))
       (a :href "http://firstfighterwing.com"
          :target "_blank"
          (img :id "winglogo"
               :src "images/1stVFW_Insignia-64.png"))))

(def keymap {97 :a
             98 :b
             99 :c
             108 :l
             110 :n
             112 :p
             78 :N
             80 :P
             ;; TODO: The rest
             })

(defn scroll-to
  [id]
  (let [body (js/jQuery "body,html")
        elem (js/jQuery (gdom/getElement id))]
    (.animate body (clj->js {:scrollTop (.-top (.offset elem))}))))

(def key-action {:a #(scroll-to "aoa")
                 :b #(scroll-to "elevation")
                 :c #(scroll-to "plan")
                 :l #(load-acmi nil)
                 :n next-pass
                 :p prev-pass})

(defn keypress
  [e]
  (log/debug "Key pressed" :which (.-which e))
  (when-let [action (some-> e .-which keymap key-action)]
    (action)))

(html
 (head
  (title "LSOBot")
  (link :href "style.css" :rel "stylesheet" :title "main" :type "text/css")
  (link :href "https://fonts.googleapis.com/css?family=Open+Sans+Condensed:300"
        :rel "stylesheet"
        :type "text/css"))
 (body
  :keypress keypress
  titlebar
  (if-tpl loading?
    [(div
      :id "loading-placeholder"
      (span
       :id "loading-placeholder-message"
       "Loading...")
      (img :id "spinner" :src "images/spinner.gif"))]
    (button :click load-acmi "Load ACMI"))
  (formula-of
   [acmi passes]
   (cond
     (not acmi) (div "No ACMI file loaded")
     (empty? passes) (div "No passes detected in loaded ACMI")
     :else pass-selection-ui))
  aoa
  elevation
  plan))

(comment
  ;; This draw the table of passes. Might use it again
  (table
   :id "passes"
   (thead (tr (td) (td "Carrier") (td "Pilot") (td "Pass time")))
   (tbody
    (for-tpl [{:keys [carrier-id pilot-id start index]} passes]
      (do
        (log/debug :index index
                   :carrier-id carrier-id
                   :pilot-id pilot-id)
        (tr
         (td (input :type "radio"
                    :name "pass"
                    :click #(reset! selected-pass-index @index)
                    :checked (formula-of
                              [selected-pass-index]
                              (= selected-pass-index index))))
         (td (cell= (property carrier-id "Name")))
         (td (cell= (property pilot-id ::acmi/pilot)))
         (td (cell= (time-str reference-time start))))))))
  )
